<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>レシピ取得テスト — Recipe Box</title>
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../assets/css/style.css?v=20250116ai">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- GitHub Pages用設定（直接埋め込み） -->
  <script>
    window.APP_CONFIG = {
      // Supabase設定（本番環境）
      SUPABASE_URL: 'https://ctxyawinblwcbkovfsyj.supabase.co',
      SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN0eHlhd2luYmx3Y2Jrb3Zmc3lqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ5NzE3MzIsImV4cCI6MjA3MDU0NzczMn0.HMMoDl_LPz8uICruD_tzn75eUpU7rp3RZx_N8CEfO1Q',
      
      // API設定
      API_BASE_URL: 'https://ctxyawinblwcbkovfsyj.supabase.co/functions/v1',
      
      // アプリ設定
      APP_NAME: 'Recipe Keeper',
      VERSION: '1.0.0',
      
      // GitHub Pages用設定
      IS_GITHUB_PAGES: true,
      BASE_PATH: '/recipes'
    };
    
    console.log('✅ GitHub Pages設定ロード完了:', window.APP_CONFIG);
  </script>
  <script src="../assets/js/utils.js"></script>
  <style>
    :root {
      color-scheme: light dark;
      /* ライトモード */
      --bg-primary: #f6f8fa;
      --bg-surface: #ffffff;
      --text-primary: #1f2933;
      --text-secondary: #64748b;
      --border-color: rgba(148, 163, 184, 0.25);
      --accent-primary: #6366f1;
      --success-color: #059669;
      --warning-color: #d97706;
      --error-color: #dc2626;
    }
    
    @media (prefers-color-scheme: dark) {
      :root {
        /* ダークモード */
        --bg-primary: #0f172a;
        --bg-surface: #1e293b;
        --text-primary: #f8fafc;
        --text-secondary: #94a3b8;
        --border-color: rgba(148, 163, 184, 0.2);
        --accent-primary: #818cf8;
        --success-color: #10b981;
        --warning-color: #f59e0b;
        --error-color: #ef4444;
      }
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
    }
    
    main {
      flex: 1;
      padding: 2rem 1.5rem 4rem;
      max-width: 1200px;
      margin: 0 auto;
      width: 100%;
    }
    
    @media (max-width: 768px) {
      main {
        padding: 1.5rem 1rem 3rem;
      }
    }
    
    .import-card {
      background: var(--bg-surface);
      border-radius: 20px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.12);
      padding: clamp(2rem, 4vw, 3rem);
      border: 1px solid var(--border-color);
      margin-bottom: 3rem;
      transition: box-shadow 0.3s ease;
    }
    
    .import-card:hover {
      box-shadow: 0 25px 55px rgba(15, 23, 42, 0.15);
    }
    
    .import-card header {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 2rem;
      text-align: center;
    }
    
    .import-card h1 {
      font-size: clamp(1.6rem, 4vw, 2.2rem);
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      background: linear-gradient(135deg, var(--accent-primary), #4f46e5);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 700;
    }
    
    .import-card h1 i {
      background: linear-gradient(135deg, var(--accent-primary), #4f46e5);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .import-card p {
      margin: 0 auto;
      color: var(--text-secondary);
      line-height: 1.6;
      font-size: 1rem;
      max-width: 600px;
    }
    
    form {
      display: grid;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    
    label {
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-size: 0.95rem;
    }
    
    input[type="url"] {
      width: 100%;
      padding: 0.75rem 0.85rem;
      border-radius: 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-surface);
      color: var(--text-primary);
      font-size: 0.95rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    
    input[type="url"]:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15);
    }
    
    .api-selector {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    
    .api-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-surface);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .api-option:hover {
      border-color: var(--accent-primary);
    }
    
    .api-option input[type="radio"] {
      margin: 0;
    }
    
    .api-option.selected {
      border-color: var(--accent-primary);
      background: rgba(99, 102, 241, 0.1);
    }
    
    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      padding: 0.85rem 1.6rem;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }
    
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 15px 35px rgba(99, 102, 241, 0.25);
    }
    
    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .button-group {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }
    
    .button-group button {
      flex: 1;
      min-width: 140px;
    }
    
    .btn.secondary {
      background: linear-gradient(135deg, #64748b, #475569);
      color: white;
    }
    
    .btn.secondary:hover:not(:disabled) {
      background: linear-gradient(135deg, #475569, #334155);
      box-shadow: 0 15px 35px rgba(100, 116, 139, 0.25);
    }
    
    /* モーダルスタイル */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .modal-content {
      background: var(--bg-surface);
      border-radius: 16px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.3);
      max-width: 600px;
      width: 95%;
      max-height: 90vh;
      overflow-y: auto;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    
    .modal-title {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
    }
    
    .modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-secondary);
      padding: 0.25rem;
      border-radius: 4px;
      transition: color 0.2s ease;
    }
    
    .modal-close:hover {
      color: var(--text-primary);
    }
    
    .modal-body {
      padding: 1.5rem;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
      white-space: normal;
    }
    
    .modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: flex-end;
    }
    
    .image-upload-section {
      text-align: center;
      padding: 2rem 1rem;
      border: 2px dashed var(--border-color);
      border-radius: 12px;
      background: var(--bg-primary);
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
      white-space: normal;
      max-width: 100%;
      box-sizing: border-box;
    }
    
    .image-upload-section:hover {
      border-color: var(--accent-primary);
      background: rgba(99, 102, 241, 0.05);
    }
    
    .image-upload-section.drag-over {
      border-color: var(--accent-primary);
      background: rgba(99, 102, 241, 0.1);
      border-style: solid;
      transform: scale(1.02);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.15);
    }
    
    .image-upload-section.drag-over::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(99, 102, 241, 0.1);
      border-radius: 10px;
      pointer-events: none;
    }
    
    .drag-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(99, 102, 241, 0.9);
      border-radius: 10px;
      display: none;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 1.2rem;
      font-weight: 600;
      z-index: 10;
    }
    
    .image-upload-section.drag-over .drag-overlay {
      display: flex;
    }
    
    .btn.ghost {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border-color);
    }
    
    .btn.ghost:hover:not(:disabled) {
      background: var(--bg-primary);
      color: var(--text-primary);
      box-shadow: none;
    }
    
    .btn.primary {
      background: linear-gradient(135deg, var(--accent-primary), #4f46e5);
      color: white;
    }
    
    .status {
      display: flex;
      align-items: center;
      gap: 0.65rem;
      font-size: 0.95rem;
      color: var(--text-secondary);
      min-height: 1.2rem;
      margin: 1rem 0;
    }
    
    .status i {
      color: var(--accent-primary);
    }
    
    .status.success {
      color: var(--success-color);
    }
    
    .status.warning {
      color: var(--warning-color);
    }
    
    .status.error {
      color: var(--error-color);
    }
    
    .results-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-top: 2rem;
      min-width: 0;
      overflow: hidden;
    }
    
    @media (max-width: 768px) {
      .results-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .result-section {
      background: var(--bg-surface);
      border-radius: 16px;
      border: 1px solid var(--border-color);
      padding: 2rem;
      min-width: 0;
      overflow: hidden;
      word-wrap: break-word;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.08);
      transition: box-shadow 0.2s ease;
    }
    
    .result-section:hover {
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.12);
    }
    
    .result-section h3 {
      margin: 0 0 1.5rem 0;
      font-size: 1.25rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      color: var(--text-primary);
      border-bottom: 2px solid var(--border-color);
      padding-bottom: 0.75rem;
    }
    
    .result-section h3 i {
      color: var(--accent-primary);
    }
    
    .recipe-preview {
      display: grid;
      gap: 1rem;
    }
    
    .recipe-field {
      display: grid;
      gap: 0.25rem;
    }
    
    .recipe-field label {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin: 0;
    }
    
    .recipe-field .value {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 0.5rem;
      font-size: 0.9rem;
      min-height: 1.2rem;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      white-space: normal;
      line-height: 1.4;
    }
    
    .ingredients-list, .steps-list {
      display: grid;
      gap: 0.5rem;
    }
    
    .ingredient-item, .step-item {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 0.5rem;
      font-size: 0.9rem;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      white-space: normal;
      line-height: 1.4;
    }
    
    /* テーブルスタイル改善 */
    .table {
      width: 100%;
      max-width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
      border-spacing: 0;
      margin: 1rem 0;
      background: var(--bg-surface);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .table th,
    .table td {
      padding: 0.75rem 0.5rem;
      text-align: left;
      vertical-align: top;
      word-wrap: break-word !important;
      word-break: break-word !important;
      overflow-wrap: break-word !important;
      white-space: normal !important;
      line-height: 1.4;
      border-bottom: 1px solid var(--border-color);
      max-width: 0;
    }
    
    .table th {
      background: var(--accent-primary);
      color: white;
      font-weight: 600;
      font-size: 0.9rem;
    }
    
    .table td {
      font-size: 0.9rem;
      color: var(--text-primary);
    }
    
    /* 列幅の調整 */
    .table th:nth-child(1),
    .table td:nth-child(1) {
      width: 8%;
      text-align: center;
    }
    
    .table th:nth-child(2),
    .table td:nth-child(2) {
      width: 45%;
    }
    
    .table th:nth-child(3),
    .table td:nth-child(3) {
      width: 25%;
      text-align: right;
    }
    
    .table th:nth-child(4),
    .table td:nth-child(4) {
      width: 22%;
      text-align: center;
    }
    
    /* レスポンシブ対応 */
    @media (max-width: 768px) {
      .table th,
      .table td {
        padding: 0.5rem 0.25rem;
        font-size: 0.8rem;
      }
      
      .table th:nth-child(2),
      .table td:nth-child(2) {
        width: 40%;
      }
      
      .table th:nth-child(3),
      .table td:nth-child(3) {
        width: 30%;
      }
    }
    
    
    /* 文字列見切れ防止の包括的設定 */
    * {
      word-wrap: break-word !important;
      word-break: break-word !important;
      overflow-wrap: break-word !important;
      white-space: normal !important;
      box-sizing: border-box !important;
    }
    
    p, span, div, label, button, input, textarea, select {
      word-wrap: break-word !important;
      word-break: break-word !important;
      overflow-wrap: break-word !important;
      white-space: normal !important;
      line-height: 1.5 !important;
    }
    
    .example-urls {
      display: grid;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    
    .example-url {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      transition: border-color 0.2s ease;
    }
    
    .example-url:hover {
      border-color: var(--accent-primary);
    }
    
    .example-url .url {
      flex: 1;
      font-family: monospace;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    .example-url .label {
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .translate-btn {
      appearance: none;
      border: none;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      padding: 0.6rem 1.2rem;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
      width: 100%;
    }
    
    .translate-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(16, 185, 129, 0.25);
    }
    
    .translate-btn:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .translation-selector {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }
    
    .translation-selector label {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 0.9rem;
      min-width: max-content;
    }
    
    .language-select {
      appearance: none;
      background: var(--bg-surface);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 0.5rem 2rem 0.5rem 0.75rem;
      font-size: 0.9rem;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s ease;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 0.5rem center;
      background-repeat: no-repeat;
      background-size: 1.5em 1.5em;
      min-width: 200px;
    }
    
    .language-select:hover {
      border-color: var(--accent-primary);
    }
    
    .language-select:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    
    @media (max-width: 768px) {
      .translation-selector {
        flex-direction: column;
        align-items: stretch;
        gap: 0.5rem;
      }
      
      .language-select {
        min-width: unset;
        width: 100%;
      }
    }
    
    .results-grid.with-translation {
      grid-template-columns: 1fr 1fr 1fr;
    }
    
    @media (max-width: 1024px) {
      .results-grid.with-translation {
        grid-template-columns: 1fr;
      }
    }
    
    /* フレキシブルレシピ表示 */
    .recipe-section {
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: var(--bg-surface);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      overflow: hidden;
      word-wrap: break-word;
    }
    
    .recipe-section-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--accent-primary);
      margin-bottom: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      line-height: 1.3;
    }
    
    .recipe-section-weight {
      font-size: 0.9rem;
      color: var(--text-secondary);
      font-style: italic;
      margin-bottom: 0.5rem;
      word-wrap: break-word;
    }
    
    .recipe-ingredients-grid {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 0.5rem;
      align-items: start;
      margin-bottom: 0.75rem;
      min-width: 0;
    }
    
    .ingredient-name {
      font-weight: 500;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      min-width: 0;
      line-height: 1.4;
    }
    
    .ingredient-quantity {
      text-align: right;
      font-weight: 600;
      color: var(--accent-primary);
      white-space: nowrap;
      flex-shrink: 0;
    }
    
    .ingredient-unit {
      font-size: 0.9rem;
      color: var(--text-secondary);
      min-width: 40px;
      white-space: nowrap;
      flex-shrink: 0;
    }
    
    .recipe-instructions {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border-color);
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .recipe-instructions p {
      margin-bottom: 0.5rem;
      line-height: 1.5;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
    }
    
    /* モバイル対応 */
    @media (max-width: 768px) {
      .recipe-ingredients-grid {
        grid-template-columns: 1fr;
        gap: 0.25rem;
        align-items: stretch;
      }
      
      .ingredient-name {
        font-weight: 600;
        margin-bottom: 0.25rem;
      }
      
      .ingredient-quantity,
      .ingredient-unit {
        text-align: left;
        font-size: 0.9rem;
        color: var(--text-secondary);
      }
      
      .ingredient-quantity::after {
        content: " ";
      }
      
      .recipe-section-title {
        font-size: 1rem;
        line-height: 1.2;
      }
    }
  </style>
</head>
<body>
  <main>
    <section class="import-card">
      <header>
        <h1><i class="fa-solid fa-robot"></i> レシピ自動取得テスト</h1>
        <p>Recipe Keeper.appのレシピ取得システムをテストします。URLを入力すると、AI（Groq/ChatGPT）がWebサイトからレシピ情報を自動抽出します。</p>
      </header>

      <form id="importForm">
        <label>
          レシピサイトURL
          <input type="url" id="urlInput" name="url" placeholder="https://cookpad.com/recipe/123456" required>
          <small style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 0.25rem;">
            対応サイト: クックパッド、クラシル、Marmiton、DelishKitchen、料理王国など
          </small>
        </label>

        <label>
          AI API選択
          <div class="api-selector">
            <div class="api-option selected" data-api="groq">
              <input type="radio" name="api" value="groq" checked>
              <span>Groq (推奨)</span>
            </div>
            <div class="api-option" data-api="chatgpt">
              <input type="radio" name="api" value="chatgpt">
              <span>ChatGPT</span>
            </div>
            <div class="api-option" data-api="gemini">
              <input type="radio" name="api" value="gemini">
              <span>Gemini</span>
            </div>
          </div>
        </label>

        <div class="button-group">
          <button type="submit" id="importButton">
            <i class="fa-solid fa-download"></i> レシピを取得
          </button>
          <button type="button" id="imageImportBtn" class="btn secondary">
            <i class="fas fa-camera"></i> 画像解析
          </button>
        </div>
      </form>

      <div class="status" id="statusRow"></div>

      <div class="example-urls">
        <h3>テスト用URL例</h3>
        <div class="example-url" data-url="https://cookpad.com/recipe/2798655">
          <span class="label">クックパッド:</span>
          <span class="url">https://cookpad.com/recipe/2798655</span>
          <i class="fa-solid fa-copy"></i>
        </div>
        <div class="example-url" data-url="https://www.kurashiru.com/recipes/c2b1c7c0-1234-5678-9abc-def012345678">
          <span class="label">クラシル:</span>
          <span class="url">https://www.kurashiru.com/recipes/...</span>
          <i class="fa-solid fa-copy"></i>
        </div>
        <div class="example-url" data-url="https://www.marmiton.org/recettes/recette_quiche-lorraine_11242.aspx">
          <span class="label">Marmiton (仏):</span>
          <span class="url">https://www.marmiton.org/recettes/...</span>
          <i class="fa-solid fa-copy"></i>
        </div>
      </div>
    </section>

    <div class="results-grid" id="resultsGrid" hidden>
      <div class="result-section">
        <h3><i class="fa-solid fa-utensils"></i> 抽出されたレシピ（元言語）</h3>
        <div class="recipe-preview" id="recipePreview">
          <div class="recipe-field">
            <label>タイトル</label>
            <div class="value" id="recipeTitle">-</div>
          </div>
          <div class="recipe-field">
            <label>説明</label>
            <div class="value" id="recipeDescription">-</div>
          </div>
          <div class="recipe-field">
            <label>人数</label>
            <div class="value" id="recipeServings">-</div>
          </div>
          <div class="recipe-field">
            <label>材料</label>
            <div id="flexibleIngredientsDisplay">
              <div class="ingredient-item">材料なし</div>
            </div>
          </div>
          <div class="recipe-field">
            <label>手順</label>
            <div class="steps-list" id="stepsList">
              <div class="step-item">手順なし</div>
            </div>
          </div>
        </div>
        
        <div class="translation-controls" id="translationControls" style="margin-top: 1rem;">
          <div class="translation-selector">
            <label for="targetLanguage">翻訳先言語:</label>
            <select id="targetLanguage" class="language-select">
              <option value="japanese">🇯🇵 日本語 (Japanese)</option>
              <option value="english">🇺🇸 英語 (English)</option>
              <option value="french">🇫🇷 フランス語 (Français)</option>
              <option value="italian">🇮🇹 イタリア語 (Italiano)</option>
              <option value="german">🇩🇪 ドイツ語 (Deutsch)</option>
              <option value="spanish">🇪🇸 スペイン語 (Español)</option>
              <option value="korean">🇰🇷 韓国語 (한국어)</option>
              <option value="chinese">🇨🇳 中国語 (中文)</option>
            </select>
          </div>
          <button type="button" id="translateButton" class="translate-btn">
            <i class="fa-solid fa-language"></i> <span id="translateButtonText">翻訳する</span>
          </button>
        </div>
      </div>

      <div class="result-section" id="translationSection" style="display: none;">
        <h3><i class="fa-solid fa-language"></i> <span id="translationSectionTitle">翻訳結果</span></h3>
        <div class="recipe-preview" id="translatedRecipePreview">
          <div class="recipe-field">
            <label>タイトル</label>
            <div class="value" id="translatedRecipeTitle">-</div>
          </div>
          <div class="recipe-field">
            <label>説明</label>
            <div class="value" id="translatedRecipeDescription">-</div>
          </div>
          <div class="recipe-field">
            <label>人数</label>
            <div class="value" id="translatedRecipeServings">-</div>
          </div>
          <div class="recipe-field">
            <label>材料</label>
            <div id="flexibleTranslatedIngredientsDisplay">
              <div class="ingredient-item">翻訳なし</div>
            </div>
          </div>
          <div class="recipe-field">
            <label>手順</label>
            <div class="steps-list" id="translatedStepsList">
              <div class="step-item">翻訳なし</div>
            </div>
          </div>
        </div>
      </div>

    </div>
  </main>

  <!-- 画像解析モーダル -->
  <div id="image-import-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">画像からレシピを抽出</h2>
        <button id="image-import-modal-close-btn" class="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div class="image-upload-section" id="uploadArea">
          <div class="drag-overlay">
            <div>
              <i class="fas fa-download" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
              <div>画像をドロップしてください</div>
            </div>
          </div>
          <i class="fas fa-cloud-upload-alt" style="font-size: 3rem; color: #666; margin-bottom: 1rem;"></i>
          <p style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem; word-wrap: break-word; word-break: break-word; overflow-wrap: break-word; white-space: normal; max-width: 100%;">レシピ画像をアップロードしてください</p>
          <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1.5rem; word-wrap: break-word; word-break: break-word; overflow-wrap: break-word; white-space: normal; max-width: 100%; line-height: 1.5;">
            画像をここにドラッグ&ドロップするか、下のボタンから選択してください
          </p>
          <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;">
            <button type="button" id="fileSelectBtn" class="btn primary">
              <i class="fas fa-folder-open"></i> ファイルから選択
            </button>
            <button type="button" id="cameraBtn" class="btn secondary">
              <i class="fas fa-camera"></i> カメラで撮影
            </button>
          </div>
          <input type="file" id="imageInput" accept="image/*" style="display: none;">
          <input type="file" id="cameraInput" accept="image/*" capture="user" style="display: none;">
        </div>
        
        <div id="previewArea" style="display: none; text-align: center; margin-top: 1rem;">
          <img id="previewImage" class="image-preview" alt="プレビュー" style="max-width: 100%; max-height: 300px; border-radius: 8px;">
          <div style="margin-top: 1rem;">
            <button type="button" id="analyzeButton" class="btn" type="button">
              <i class="fas fa-search"></i> 解析してレシピを抽出
            </button>
            <button type="button" id="clearImageButton" class="btn ghost">
              <i class="fas fa-trash"></i> クリア
            </button>
          </div>
        </div>
        
        <div id="imageMessageArea" style="margin-top: 1rem;"></div>
      </div>
      <div class="modal-footer">
        <button id="imageImportCancelBtn" class="btn ghost" type="button">閉じる</button>
      </div>
    </div>
  </div>

  <script>
    const statusRow = document.getElementById('statusRow');
    const resultsGrid = document.getElementById('resultsGrid');
    const importButton = document.getElementById('importButton');
    const urlInput = document.getElementById('urlInput');
    const translateButton = document.getElementById('translateButton');
    const translationSection = document.getElementById('translationSection');
    const translationControls = document.getElementById('translationControls');
    const targetLanguageSelect = document.getElementById('targetLanguage');
    const translateButtonText = document.getElementById('translateButtonText');
    const translationSectionTitle = document.getElementById('translationSectionTitle');
    
    // 画像解析用の変数
    let currentFile = null;
    const imageImportBtn = document.getElementById('imageImportBtn');
    const imageModal = document.getElementById('image-import-modal');
    const imageModalCloseBtn = document.getElementById('image-import-modal-close-btn');
    const imageImportCancelBtn = document.getElementById('imageImportCancelBtn');
    const fileSelectBtn = document.getElementById('fileSelectBtn');
    const cameraBtn = document.getElementById('cameraBtn');
    const imageInput = document.getElementById('imageInput');
    const cameraInput = document.getElementById('cameraInput');
    const previewArea = document.getElementById('previewArea');
    const previewImage = document.getElementById('previewImage');
    const analyzeButton = document.getElementById('analyzeButton');
    const clearImageButton = document.getElementById('clearImageButton');
    const imageMessageArea = document.getElementById('imageMessageArea');
    
    let currentRecipeData = null;
    let isJapaneseContent = false;
    
    let sb;
    
    // Supabaseクライアントを初期化
    const initSupabase = () => {
      try {
        if (typeof supabase !== 'undefined' && window.APP_CONFIG) {
          sb = supabase.createClient(
            window.APP_CONFIG.SUPABASE_URL,
            window.APP_CONFIG.SUPABASE_ANON_KEY
          );
          console.log('✅ Supabaseクライアント初期化成功');
          return true;
        } else {
          console.error('❌ Supabase または APP_CONFIG が利用できません');
          return false;
        }
      } catch (error) {
        console.error('❌ Supabaseクライアント初期化エラー:', error);
        return false;
      }
    };

    const setStatus = (message, type = 'info', icon = 'fa-spinner fa-spin') => {
      if (!message) {
        statusRow.textContent = '';
        statusRow.className = 'status';
        return;
      }
      
      statusRow.className = `status ${type}`;
      statusRow.innerHTML = `<i class="fa-solid ${icon}"></i><span>${message}</span>`;
    };

    // API選択の処理
    document.querySelectorAll('.api-option').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('.api-option').forEach(opt => opt.classList.remove('selected'));
        option.classList.add('selected');
        option.querySelector('input[type="radio"]').checked = true;
      });
    });

    // 例URL選択の処理
    document.querySelectorAll('.example-url').forEach(example => {
      example.addEventListener('click', () => {
        const url = example.dataset.url;
        urlInput.value = url;
        urlInput.focus();
      });
    });

    // ページ読み込み時にSupabaseを初期化
    window.addEventListener('load', () => {
      if (!initSupabase()) {
        setStatus('Supabaseクライアントの初期化に失敗しました', 'error', 'fa-triangle-exclamation');
      }
    });

    // 画像解析モーダルのイベントリスナー
    imageImportBtn.addEventListener('click', () => {
      imageModal.style.display = 'flex';
    });

    imageModalCloseBtn.addEventListener('click', closeImageModal);
    imageImportCancelBtn.addEventListener('click', closeImageModal);

    imageModal.addEventListener('click', (e) => {
      if (e.target === imageModal) {
        closeImageModal();
      }
    });

    fileSelectBtn.addEventListener('click', () => {
      const newInput = document.createElement('input');
      newInput.type = 'file';
      newInput.accept = 'image/*';
      newInput.style.position = 'absolute';
      newInput.style.left = '-9999px';
      newInput.style.top = '-9999px';
      newInput.style.opacity = '0';

      const handleNewInputChange = (event) => {
        if (event.target.files && event.target.files.length > 0) {
          const file = event.target.files[0];
          handleFile(file);
        }
        setTimeout(() => {
          if (document.body.contains(newInput)) {
            document.body.removeChild(newInput);
          }
        }, 100);
      };

      newInput.addEventListener('change', handleNewInputChange);
      newInput.addEventListener('input', handleNewInputChange);

      document.body.appendChild(newInput);
      setTimeout(() => {
        newInput.click();
      }, 10);
    });

    cameraBtn.addEventListener('click', () => {
      const newInput = document.createElement('input');
      newInput.type = 'file';
      newInput.accept = 'image/*';
      newInput.setAttribute('capture', 'user');
      newInput.style.position = 'absolute';
      newInput.style.left = '-9999px';
      newInput.style.top = '-9999px';
      newInput.style.opacity = '0';

      const handleCameraInputChange = (event) => {
        if (event.target.files && event.target.files.length > 0) {
          const file = event.target.files[0];
          handleFile(file);
        }
        setTimeout(() => {
          if (document.body.contains(newInput)) {
            document.body.removeChild(newInput);
          }
        }, 100);
      };

      newInput.addEventListener('change', handleCameraInputChange);
      newInput.addEventListener('input', handleCameraInputChange);

      document.body.appendChild(newInput);
      setTimeout(() => {
        newInput.click();
      }, 10);
    });

    analyzeButton.addEventListener('click', analyzeImage);
    clearImageButton.addEventListener('click', clearImage);

    // 言語選択の変更イベント
    targetLanguageSelect.addEventListener('change', updateTranslationUI);

    // ページ全体でのドラッグ&ドロップを防止
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    document.addEventListener('drop', (e) => {
      e.preventDefault();
    });

    // ドラッグ&ドロップイベントリスナー
    const uploadArea = document.getElementById('uploadArea');
    
    // ドラッグ&ドロップイベントの設定
    uploadArea.addEventListener('dragover', handleDragOver);
    uploadArea.addEventListener('dragenter', handleDragEnter);
    uploadArea.addEventListener('dragleave', handleDragLeave);
    uploadArea.addEventListener('drop', handleDrop);
    
    // クリックでファイル選択
    uploadArea.addEventListener('click', (e) => {
      // ボタンクリック時は除外
      if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
        return;
      }
      fileSelectBtn.click();
    });

    // ドラッグ&ドロップハンドラー関数
    function handleDragOver(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function handleDragEnter(e) {
      e.preventDefault();
      e.stopPropagation();
      uploadArea.classList.add('drag-over');
    }

    function handleDragLeave(e) {
      e.preventDefault();
      e.stopPropagation();
      
      // 子要素から出た場合は無視
      if (!uploadArea.contains(e.relatedTarget)) {
        uploadArea.classList.remove('drag-over');
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      uploadArea.classList.remove('drag-over');

      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        
        // 画像ファイルかチェック
        if (file.type.startsWith('image/')) {
          handleFile(file);
        } else {
          showImageMessage('画像ファイルをドロップしてください', 'error');
        }
      }
    }

    function updateTranslationUI() {
      const selectedLanguage = targetLanguageSelect.value;
      const languageNames = {
        japanese: '日本語',
        english: '英語',
        french: 'フランス語',
        italian: 'イタリア語',
        german: 'ドイツ語',
        spanish: 'スペイン語',
        korean: '韓国語',
        chinese: '中国語'
      };
      
      const languageName = languageNames[selectedLanguage] || '選択言語';
      translateButtonText.textContent = `${languageName}に翻訳`;
      translationSectionTitle.textContent = `${languageName}翻訳`;
    }

    function closeImageModal() {
      imageModal.style.display = 'none';
    }

    function handleFile(file) {
      if (!file || !file.type.startsWith('image/')) {
        showImageMessage('画像ファイルを選択してください', 'error');
        return;
      }

      currentFile = file;
      window.__ocrCurrentFile = file;
      window.currentImageFiles = [file];

      // プレビュー表示
      const reader = new FileReader();
      reader.onload = (e) => {
        previewImage.src = e.target.result;
        previewArea.style.display = 'block';
        document.getElementById('uploadArea').style.display = 'none';
        analyzeButton.disabled = false;
      };
      reader.readAsDataURL(file);

      showImageMessage('画像が選択されました。「解析してレシピを抽出」ボタンをクリックしてください。', 'success');
    }

    function clearImage() {
      currentFile = null;
      window.__ocrCurrentFile = null;
      window.currentImageFiles = [];
      previewImage.src = '';
      previewArea.style.display = 'none';
      document.getElementById('uploadArea').style.display = 'block';
      analyzeButton.disabled = true;
      showImageMessage('', '');
    }

    function showImageMessage(message, type) {
      if (!message) {
        imageMessageArea.innerHTML = '';
        return;
      }

      const icons = {
        success: 'fa-check-circle',
        error: 'fa-exclamation-triangle',
        info: 'fa-info-circle',
        loading: 'fa-spinner fa-spin'
      };

      const colors = {
        success: 'var(--success-color)',
        error: 'var(--error-color)',
        info: 'var(--accent-primary)',
        loading: 'var(--accent-primary)'
      };

      imageMessageArea.innerHTML = `
        <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem; border-radius: 8px; background: ${colors[type] || colors.info}15; color: ${colors[type] || colors.info}; border: 1px solid ${colors[type] || colors.info}25;">
          <i class="fas ${icons[type] || icons.info}"></i>
          <span>${message}</span>
        </div>
      `;
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(new Error('ファイルの読み込みに失敗しました'));
        reader.readAsDataURL(file);
      });
    }

    function getActiveOcrFile() {
      if (currentFile instanceof File) {
        return currentFile;
      }
      if (window.__ocrCurrentFile instanceof File) {
        return window.__ocrCurrentFile;
      }
      if (Array.isArray(window.currentImageFiles) && window.currentImageFiles.length > 0) {
        const candidate = window.currentImageFiles.find(f => f instanceof File);
        if (candidate) {
          window.__ocrCurrentFile = candidate;
          currentFile = candidate;
          return candidate;
        }
      }
      return null;
    }

    async function analyzeWithAzureDocumentIntelligence(base64Payload, selectedProvider, providerInfo) {
      console.log('🛰️ Azure Document Intelligence呼び出し準備', { selectedProvider });

      const { data: docResult, error: docError } = await sb.functions.invoke('call-document-intelligence', {
        body: {
          image: base64Payload,
          processorType: 'RECIPE_PROCESSOR',
          aiProvider: selectedProvider
        }
      });

      if (docError) {
        console.error('❌ call-document-intelligence error:', docError);
        throw new Error(docError.message || docError.error || 'Azure Document Intelligence呼び出しに失敗しました');
      }

      if (!docResult?.success) {
        console.error('❌ call-document-intelligence response error:', docResult);
        throw new Error(docResult?.error || '画像解析に失敗しました');
      }

      const recipeData = docResult.data;
      if (!recipeData || typeof recipeData !== 'object') {
        throw new Error('レシピデータが取得できませんでした');
      }

      recipeData.aiProvider = selectedProvider;
      recipeData.aiProviderModel = providerInfo?.model || null;

      console.log('📄 Azure + AI解析結果:', recipeData);
      return recipeData;
    }

    async function analyzeWithVisionFallback(base64Payload, fileType, selectedProvider, providerInfo) {
      const mimeType = fileType || 'image/png';
      console.log('🛰️ Gemini Visionフォールバック開始', { selectedProvider, mimeType });

      const { data: visionResult, error: visionError } = await sb.functions.invoke('call-vision-api', {
        body: {
          contents: [{
            parts: [
              {
                text: 'Extract all text from this recipe image. Preserve Japanese characters, numbers, and line breaks as they appear.'
              },
              {
                inline_data: {
                  mime_type: mimeType,
                  data: base64Payload
                }
              }
            ]
          }]
        }
      });

      if (visionError) {
        console.error('❌ call-vision-api error:', visionError);
        throw new Error(visionError.message || visionError.error || 'Gemini Vision呼び出しに失敗しました');
      }

      const extractedTextParts = visionResult?.candidates?.[0]?.content?.parts || [];
      const extractedText = extractedTextParts
        .map(part => part?.text || '')
        .filter(Boolean)
        .join('\n')
        .trim();

      if (!extractedText) {
        console.error('❌ Gemini Visionから有効なテキストが取得できませんでした:', visionResult);
        throw new Error('Gemini Visionからテキストを取得できませんでした');
      }

      console.log('📝 Gemini Vision抽出テキスト(冒頭):', extractedText.substring(0, 200));

      // 抽出したテキストをAI解析システムに送る
      const selectedApi = document.querySelector('input[name="api"]:checked').value;
      const recipeData = await analyzeRecipeWithAI(extractedText, null, selectedApi);
      
      if (!recipeData || typeof recipeData !== 'object') {
        throw new Error('AI解析結果が無効です');
      }
      
      recipeData.aiProvider = recipeData.aiProvider || selectedProvider;
      recipeData.aiProviderModel = recipeData.aiProviderModel || providerInfo?.model || null;
      
      console.log('✅ Gemini Vision + AI解析成功:', {
        provider: recipeData.aiProvider,
        ingredients: recipeData.ingredients?.length || 0,
        steps: recipeData.steps?.length || 0
      });
      
      return recipeData;
    }

    async function analyzeImage() {
      console.log('🔍 analyzeImage function called');
      const activeFile = getActiveOcrFile();
      
      if (!activeFile) {
        console.error('❌ No currentFile available');
        showImageMessage('画像を選択してください', 'error');
        return;
      }

      showImageMessage('AzureでOCR解析を開始しました...', 'loading');
      analyzeButton.disabled = true;

      try {
        const base64 = await fileToBase64(activeFile);
        console.log('✅ Base64 conversion completed, size:', base64.length);
        const base64Payload = base64.includes(',') ? base64.split(',')[1] : base64;

        const selectedApi = document.querySelector('input[name="api"]:checked').value;
        const providerInfo = { key: selectedApi };
        console.log('🤖 Selected AI provider:', selectedApi);

        let recipeData = null;
        let analysisSource = '';

        try {
          showImageMessage(`AzureでOCR後、${selectedApi.toUpperCase()}で解析中...`, 'loading');
          recipeData = await analyzeWithAzureDocumentIntelligence(base64Payload, selectedApi, providerInfo);
          analysisSource = `Azure Document Intelligence + ${selectedApi.toUpperCase()}`;
        } catch (azureError) {
          console.warn('⚠️ Azure Document Intelligence解析に失敗しました。Gemini Visionフォールバックを試みます。', azureError);
          showImageMessage('Azure解析に失敗したため、Gemini Visionに切り替えています...', 'info');

          try {
            recipeData = await analyzeWithVisionFallback(base64Payload, activeFile.type, selectedApi, providerInfo);
            analysisSource = `Gemini Vision + ${selectedApi.toUpperCase()}`;
          } catch (fallbackError) {
            console.error('❌ Gemini Visionフォールバックも失敗しました', fallbackError);
            throw fallbackError;
          }
        }

        if (!recipeData || typeof recipeData !== 'object') {
          throw new Error('レシピデータが取得できませんでした');
        }

        console.log(`📄 解析結果 (${analysisSource}):`, recipeData);
        
        // 結果を表示
        displayRecipeResults(recipeData, analysisSource);
        showImageMessage('画像解析が完了しました！', 'success');
        closeImageModal();

      } catch (error) {
        console.error('❌ 画像解析エラー:', error);
        showImageMessage('画像解析に失敗しました: ' + (error.message || error), 'error');
      } finally {
        analyzeButton.disabled = !currentFile;
      }
    }

    // 翻訳ボタンのイベントリスナー
    translateButton.addEventListener('click', async () => {
      if (!currentRecipeData) {
        setStatus('翻訳するレシピデータがありません', 'error', 'fa-triangle-exclamation');
        return;
      }

      translateButton.disabled = true;
      translateButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> 翻訳中...';

      try {
        console.log('🌐 翻訳開始:', currentRecipeData);
        
        const translatedData = await translateRecipeData(currentRecipeData);
        console.log('✅ 翻訳完了:', translatedData);
        console.log('✅ 翻訳データの型:', typeof translatedData);
        console.log('✅ 翻訳データのキー:', Object.keys(translatedData || {}));
        
        console.log('🖼️ 翻訳結果表示開始...');
        displayTranslatedResults(translatedData);
        console.log('🖼️ 翻訳結果表示完了');
        
        // レイアウトを3カラムに変更
        console.log('🎨 レイアウト変更開始...');
        resultsGrid.classList.add('with-translation');
        translationSection.style.display = 'block';
        console.log('🎨 レイアウト変更完了');
        
        const selectedLanguage = targetLanguageSelect.value;
        const languageNames = {
          japanese: '日本語',
          english: '英語',
          french: 'フランス語',
          italian: 'イタリア語',
          german: 'ドイツ語',
          spanish: 'スペイン語',
          korean: '韓国語',
          chinese: '中国語'
        };
        const languageName = languageNames[selectedLanguage] || '選択言語';
        translateButton.innerHTML = `<i class="fa-solid fa-check"></i> ${languageName}翻訳完了`;
        console.log('✅ 翻訳処理全体完了');
        
      } catch (error) {
        console.error('❌ 翻訳エラー:', error);
        setStatus(`翻訳エラー: ${error.message}`, 'error', 'fa-triangle-exclamation');
        updateTranslationUI();
      } finally {
        translateButton.disabled = false;
      }
    });

    // レシピ取得フォームの処理
    document.getElementById('importForm').addEventListener('submit', async (event) => {
      event.preventDefault();

      if (!sb) {
        if (!initSupabase()) {
          setStatus('Supabaseクライアントが利用できません', 'error', 'fa-triangle-exclamation');
          return;
        }
      }

      const url = urlInput.value.trim();
      const selectedApi = document.querySelector('input[name="api"]:checked').value;

      if (!url) {
        setStatus('URLを入力してください', 'error', 'fa-circle-exclamation');
        return;
      }

      // URLの妥当性をチェック
      try {
        new URL(url);
      } catch (urlError) {
        setStatus('有効なURLを入力してください', 'error', 'fa-circle-exclamation');
        return;
      }

      resultsGrid.hidden = true;
      setStatus('HTMLを取得中です...', 'info', 'fa-spinner fa-spin');
      importButton.disabled = true;

      try {
        const startTime = Date.now();
        console.log('🚀 レシピ取得開始:', { url, selectedApi });
        
        // ステップ1: HTMLを取得
        setStatus('Webサイトからコンテンツを取得中...', 'info', 'fa-spinner fa-spin');
        const htmlData = await fetchHtmlFromUrl(url);
        
        if (!htmlData || !htmlData.html) {
          throw new Error('Webサイトのコンテンツを取得できませんでした');
        }
        
        console.log('✅ HTML取得完了:', htmlData.html.length, '文字');
        
        // ステップ2: AI解析
        setStatus(`${selectedApi.toUpperCase()} APIでレシピを解析中...`, 'info', 'fa-spinner fa-spin');
        const recipeData = await analyzeRecipeWithAI(htmlData.html, url, selectedApi);
        
        console.log('✅ AI解析完了:', recipeData);
        
        // URLを記録（翻訳時に参照するため）
        window.lastProcessedUrl = url;
        
        // 結果を表示
        displayRecipeResults(recipeData, { 
          url, 
          selectedApi, 
          htmlLength: htmlData.html.length,
          processingTime: Date.now() - startTime
        });
        
        resultsGrid.hidden = false;
        setStatus('レシピの取得が完了しました！', 'success', 'fa-circle-check');
        
      } catch (err) {
        console.error('❌ レシピ取得エラー:', err);
        setStatus(`エラー: ${err.message}`, 'error', 'fa-triangle-exclamation');
        
        resultsGrid.hidden = false;
      } finally {
        importButton.disabled = false;
      }
    });

    // HTMLを取得する関数
    async function fetchHtmlFromUrl(url) {
      const { data, error } = await sb.functions.invoke('fetch-url-content', {
        body: { url }
      });

      if (error) {
        throw new Error(`HTML取得エラー: ${error.message}`);
      }

      if (!data.success) {
        throw new Error(data.error || 'HTML取得に失敗しました');
      }

      return data;
    }

    // AIでレシピを解析する関数
    async function analyzeRecipeWithAI(html, url, apiType) {
      // サイトの言語を判定
      const siteLanguage = detectSiteLanguage(html, url);
      console.log('🌐 サイト言語判定:', siteLanguage);
      
      let functionName;
      let requestBody;
      
      // クリーンアップされたHTMLを取得
      const cleanedHtml = cleanHtml(html, url);
      
      switch (apiType) {
        case 'groq':
          functionName = 'call-groq-api';
          requestBody = {
            text: generateRecipeExtractionPrompt(cleanedHtml, url, siteLanguage),
            mode: 'recipe_extraction',
            siteLanguage: siteLanguage.code,
            isJapaneseSite: siteLanguage.isJapanese
          };
          break;
        case 'chatgpt':
          functionName = 'call-chatgpt-api';
          requestBody = {
            text: cleanHtml(html, url).substring(0, 8000),
            url: url
          };
          break;
        case 'gemini':
          functionName = 'call-gemini-api';
          requestBody = {
            text: cleanHtml(html, url).substring(0, 8000),
            url: url
          };
          break;
        default:
          throw new Error(`未対応のAPI: ${apiType}`);
      }

      console.log(`🤖 ${apiType.toUpperCase()} API呼び出し開始:`, { functionName, bodyLength: JSON.stringify(requestBody).length });
      
      const { data, error } = await sb.functions.invoke(functionName, {
        body: requestBody
      });

      console.log(`📡 ${apiType.toUpperCase()} APIレスポンス:`, { data, error });

      if (error) {
        throw new Error(`AI解析エラー: ${error.message}`);
      }

      // Groq APIの場合のレスポンス処理
      if (apiType === 'groq') {
        if (!data.success) {
          throw new Error(data.error || 'Groq API呼び出しに失敗しました');
        }
        
        // Groq APIのcontentからJSONを抽出（改良版）
        const content = data.content || '';
        console.log('🔍 Groq APIコンテンツ（全体）:', content);
        console.log('🔍 Groq APIコンテンツ（プレビュー）:', content.substring(0, 500) + '...');
        
        try {
          // 複数のJSON抽出パターンを試行
          let recipeData = null;
          
          // パターン1: 完全なJSONオブジェクト
          try {
            const fullJsonMatch = content.match(/\{[\s\S]*\}/);
            if (fullJsonMatch) {
              console.log('🔍 パターン1: 完全JSON抽出試行');
              const jsonString = fullJsonMatch[0];
              console.log('📝 抽出されたJSON:', jsonString.substring(0, 300) + '...');
              
              // JSON修正を適用
              const fixedJson = fixMalformedJson(jsonString);
              recipeData = JSON.parse(fixedJson);
              console.log('✅ パターン1成功:', recipeData.title);
            }
          } catch (e) {
            console.log('❌ パターン1失敗:', e.message);
          }
          
          // パターン2: ```json```ブロック
          if (!recipeData) {
            try {
              const codeBlockMatch = content.match(/```json\s*([\s\S]*?)\s*```/i);
              if (codeBlockMatch) {
                console.log('🔍 パターン2: コードブロック抽出試行');
                const fixedJson = fixMalformedJson(codeBlockMatch[1]);
                recipeData = JSON.parse(fixedJson);
                console.log('✅ パターン2成功:', recipeData.title);
              }
            } catch (e) {
              console.log('❌ パターン2失敗:', e.message);
            }
          }
          
          // パターン3: 行ごとの解析
          if (!recipeData) {
            try {
              console.log('🔍 パターン3: 行ごと解析試行');
              const lines = content.split('\n');
              const jsonLines = lines.filter(line => 
                line.trim().startsWith('{') || 
                line.includes('"title"') || 
                line.includes('"ingredients"') ||
                line.includes('"steps"')
              );
              
              if (jsonLines.length > 0) {
                const jsonString = jsonLines.join('\n');
                const fixedJson = fixMalformedJson(jsonString);
                recipeData = JSON.parse(fixedJson);
                console.log('✅ パターン3成功:', recipeData.title);
              }
            } catch (e) {
              console.log('❌ パターン3失敗:', e.message);
            }
          }
          
          if (recipeData) {
            console.log('✅ レシピデータ解析成功:', recipeData);
            // Recipe Keeper.app風のデータ正規化
            return normalizeRecipeData(recipeData);
          } else {
            console.log('🔄 フォールバック解析を開始');
            return fallbackAnalysis(content, url);
          }
        } catch (parseError) {
          console.error('❌ JSON解析エラー:', parseError);
          console.log('📝 生のコンテンツ（全体）:', content);
          throw new Error(`レシピデータの解析に失敗しました: ${parseError.message}`);
        }
      }

      // ChatGPT/Gemini APIの場合
      if (data.ok && data.recipeData) {
        return data.recipeData;
      } else if (data.recipeData) {
        return data.recipeData;
      } else {
        throw new Error(data.error || 'AI解析に失敗しました');
      }
    }

    // レシピ抽出用のプロンプトを生成
    function generateRecipeExtractionPrompt(cleanedText, url) {
      const isJapaneseSite = url && (
        url.includes('.jp') ||
        url.includes('japanese') ||
        /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(url) ||
        /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(cleanedText.substring(0, 1000))
      );

      const prompt = isJapaneseSite ? 
        `レシピ情報を抽出。ナビ・広告・SNS埋め込み・関連記事を無視し、本文のみ処理。

★★★CRITICAL: titleフィールドには元ページの料理名を一字一句そのままコピーしてください。絶対に翻訳、変更、解釈しないでください★★★

URL: ${url || '不明'}
テキスト: ${cleanedText.substring(0, 4000)}

JSON形式で返す:
{
  "title": "【ここに元ページの料理名をそのままコピペ】",
  "description": "レシピ説明",
  "servings": "人数（数字のみ）",
  "ingredients": [
    {"item": "材料名", "quantity": "分量（数字または適量・少々・ひとつまみ・お好みで等の曖昧な表現）", "unit": "単位（g、ml、個、枚、本、束、大さじ、小さじ、カップ等、曖昧な表現の場合は空文字）"}
  ],
  "steps": [
    {"step": "詳細な手順内容（工程名だけでなく、具体的な調理方法、温度、時間、注意点を含む完全な手順）"}
  ],
  "notes": "メモ",
  "image_url": "【レシピのメイン画像URL（wp-content/uploads等の実際の料理画像を優先、見つからない場合は空文字）】"
}

重要: 
1. 日本語コンテンツは翻訳せずそのまま抽出してください。
2. 手順は工程名だけでなく、具体的な調理方法、温度、時間、材料の使用量、注意点を含む完全な内容を抽出してください。
3. 複数の工程がある場合は、各工程の詳細な手順をすべて含めてください。
4. 「①白ネギのコンフィを作る」のようなタイトルだけでなく、「白ネギの青い部分を切り落とし、白い部分をよく洗う。オリーブオイル、ニンニク、タイム、ローリエ、塩2ｇと一緒に真空包装し、15分間スチームコンベクションオーブンのバプールモードで加熱する。」のような具体的な内容を抽出してください。

5. 材料の分量処理:
   - 曖昧な表現（「適量」「少々」「ひとつまみ」「お好みで」）→ quantityに入れ、unitは空文字
   - 数値付き単位（「大さじ3」「小さじ2」「1個」）→ 変換ルールに従って数値と単位を分離
   - 例: 「大さじ3」→ {"quantity": "45", "unit": "ml"} (液体の場合) または {"quantity": "45", "unit": "g"} (固体の場合)

変換ルール: 
- 大さじ1=15ml（液体）または15g（固体）
- 小さじ1=5ml（液体）または5g（固体）
- カップ1=200ml
- 液体材料（水、油、醤油、酒、酢、みりん、牛乳、だし、スープ、ソース、生クリーム等）=ml
- 固体材料（粉類、砂糖、塩、スパイス等）=g
- 「大さじ3」→「45」「ml」または「45」「g」に変換
- 「小さじ2」→「10」「ml」または「10」「g」に変換
- 数値と単位を必ず分離してください

JSONのみ返す。` :
        `Extract recipe information from this webpage content. Ignore navigation, ads, social media embeds, and related articles. Focus only on the main recipe content.

URL: ${url || 'Unknown'}
Text: ${cleanedText.substring(0, 4000)}

Return in JSON format:
{
  "title": "Recipe title (keep original language)",
  "description": "Recipe description",
  "servings": "Number of servings",
  "ingredients": [
    {"item": "Ingredient name", "quantity": "Amount (numbers or vague expressions like 'to taste', 'a pinch', 'as needed')", "unit": "Unit (g, ml, pieces, etc., empty string for vague expressions)"}
  ],
  "steps": [
    {"step": "Detailed cooking step (not just titles, but complete instructions including specific cooking methods, temperatures, times, ingredient amounts, and important notes)"}
  ],
  "notes": "Additional notes",
  "image_url": "Main recipe image URL"
}

Important:
1. Extract complete step instructions, not just titles or section names.
2. Include specific cooking methods, temperatures, times, ingredient amounts, and important notes for each step.
3. For complex recipes with multiple processes, include detailed instructions for each process.
4. Instead of just "① Make white leek confit", extract the full content like "Cut off the green parts of the white leeks and wash the white parts well. Vacuum pack with olive oil, garlic, thyme, bay leaves, and 2g salt, then heat in steam convection oven vapor mode for 15 minutes."
5. Ingredient quantity processing:
   - Vague expressions ("to taste", "a pinch", "as needed") → put in quantity field, leave unit empty
   - Numeric units ("3 tbsp", "2 tsp", "1 piece") → convert according to rules and separate numbers and units
   - Example: "3 tbsp" → {"quantity": "45", "unit": "ml"} (for liquids) or {"quantity": "45", "unit": "g"} (for solids)

Conversion rules:
- 1 tbsp = 15ml (liquid) or 15g (solid)
- 1 tsp = 5ml (liquid) or 5g (solid)  
- 1 cup = 200ml
- Liquid ingredients (water, oil, soy sauce, wine, vinegar, mirin, milk, broth, soup, sauce, cream, etc.) = ml
- Solid ingredients (flour, sugar, salt, spices, etc.) = g
- "3 tbsp" → "45" "ml" or "45" "g"
- "2 tsp" → "10" "ml" or "10" "g"
- Always separate numbers and units

Return only JSON.`;

      return prompt;
    }

    // HTMLをクリーニングする関数（日本語対応強化版）
    function cleanHtml(html, url) {
      console.log('🧹 HTMLクリーニング開始:', {
        originalLength: html.length,
        url: url,
        hasJapanese: /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(html)
      });
      
      // 日本語サイトかどうかを判定
      const isJapaneseSite = url && (
        url.includes('.jp') || 
        url.includes('cookpad.com') || 
        url.includes('kurashiru.com') || 
        url.includes('delishkitchen.tv')
      );
      
      // HTMLタグを除去（日本語文字は保護）
      let text = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
      text = text.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
      text = text.replace(/<nav[^>]*>[\s\S]*?<\/nav>/gi, '');
      text = text.replace(/<header[^>]*>[\s\S]*?<\/header>/gi, '');
      text = text.replace(/<footer[^>]*>[\s\S]*?<\/footer>/gi, '');
      text = text.replace(/<aside[^>]*>[\s\S]*?<\/aside>/gi, '');
      text = text.replace(/<!--[\s\S]*?-->/g, '');
      
      // HTMLエンティティをデコード（日本語文字化け対策）
      text = text.replace(/&nbsp;/g, ' ');
      text = text.replace(/&amp;/g, '&');
      text = text.replace(/&lt;/g, '<');
      text = text.replace(/&gt;/g, '>');
      text = text.replace(/&quot;/g, '"');
      text = text.replace(/&#39;/g, "'");
      text = text.replace(/&hellip;/g, '…');
      text = text.replace(/&yen;/g, '¥');
      
      // HTMLタグを除去
      text = text.replace(/<[^>]+>/g, ' ');
      
      // 日本語サイトの場合の特別処理
      if (isJapaneseSite) {
        console.log('🇯🇵 日本語サイト特別処理適用');
        // 日本語レシピサイト特有のパターンを整理
        text = text
          .replace(/材料\s*[:：]\s*/g, '\n材料：\n')
          .replace(/作り方\s*[:：]\s*/g, '\n作り方：\n')
          .replace(/手順\s*[:：]\s*/g, '\n手順：\n')
          .replace(/(\d+)\s*[．.]\s*/g, '\n$1. ');
      }
      
      // 複数の空白を整理（日本語の文字間は保護）
      text = text.replace(/[ \t]+/g, ' ');
      text = text.replace(/\n\s*\n/g, '\n');
      
      // 日本語文字を含む場合は文字フィルタリングを緩和
      if (/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text)) {
        console.log('🇯🇵 日本語文字検出 - 文字フィルタリングを緩和');
        // 日本語文字、英数字、基本的な記号のみ許可
        text = text.replace(/[^\w\s\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\u0020-\u007E\u00A0-\u00FF\u0100-\u017F\u0180-\u024F\u2000-\u206F\u2070-\u209F\u20A0-\u20CF\u2100-\u214F\u2150-\u218F\u2190-\u21FF\u2200-\u22FF\u2300-\u23FF\u2400-\u243F\u2440-\u245F\u2460-\u24FF\u2500-\u257F\u2580-\u259F\u25A0-\u25FF\u2600-\u26FF\u2700-\u27BF]/g, '');
      } else {
        // 英語サイトの場合は従来通り
        text = text.replace(/[^\w\s\u0020-\u007E\u00A0-\u00FF\u0100-\u017F\u0180-\u024F]/g, '');
      }
      
      const cleanedText = text.trim();
      
      console.log('🧹 HTMLクリーニング完了:', {
        originalLength: html.length,
        cleanedLength: cleanedText.length,
        isJapaneseSite: isJapaneseSite,
        hasJapaneseAfterCleaning: /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(cleanedText),
        preview: cleanedText.substring(0, 200) + '...'
      });
      
      return cleanedText;
    }

    // レシピ結果を表示する関数
    function displayRecipeResults(recipeData, meta) {
      const r = recipeData || {};
      currentRecipeData = r;
      
      // 言語判定
      isJapaneseContent = detectJapaneseContent(r, meta.url);
      
      // タイトル
      document.getElementById('recipeTitle').textContent = r.title || '(タイトルなし)';
      
      // 説明
      document.getElementById('recipeDescription').textContent = r.description || '(説明なし)';
      
      // 人数
      document.getElementById('recipeServings').textContent = r.servings || '(人数不明)';
      
      // 材料（フレキシブル表示）
      displayFlexibleIngredients(r, 'flexibleIngredientsDisplay', meta?.url || '');
      
      // 手順
      const stepsList = document.getElementById('stepsList');
      stepsList.innerHTML = '';
      
      if (r.steps && r.steps.length > 0) {
        r.steps.forEach((step, index) => {
          const item = document.createElement('div');
          item.className = 'step-item';
          
          // 手順の表示形式を改善（連番のダブりを防ぐ）
          let stepText = '';
          if (typeof step === 'string') {
            stepText = step;
          } else if (step && typeof step === 'object') {
            stepText = step.step || step.instruction || step.text || '';
          }
          
          // 既に番号が付いているかチェック
          const hasNumber = /^\d+\.?\s/.test(stepText.trim());
          
          if (hasNumber) {
            // 既に番号が付いている場合はそのまま表示
            item.textContent = stepText;
          } else {
            // 番号が付いていない場合は番号を追加
            item.textContent = `${index + 1}. ${stepText}`;
          }
          
          stepsList.appendChild(item);
        });
      } else {
        const item = document.createElement('div');
        item.className = 'step-item';
        item.textContent = '手順が見つかりませんでした';
        stepsList.appendChild(item);
      }
      
      // 翻訳ボタンの表示制御（常に表示）
      translationControls.style.display = 'block';
      
      // デフォルト言語を設定
      if (isJapaneseContent) {
        // 日本語コンテンツの場合、英語をデフォルトに
        targetLanguageSelect.value = 'english';
      } else {
        // 海外コンテンツの場合、日本語をデフォルトに
        targetLanguageSelect.value = 'japanese';
      }
      
      // UIを更新
      updateTranslationUI();
      
    }

    // 日本語コンテンツかどうかを判定
    function detectJapaneseContent(recipeData, url) {
      // URLから判定
      if (url && (url.includes('.jp') || url.includes('japanese') || url.includes('japan'))) {
        return true;
      }
      
      // テキスト内容から判定
      const textToCheck = [
        recipeData.title || '',
        recipeData.description || '',
        ...(recipeData.ingredients || []).map(ing => ing.item || ''),
        ...(recipeData.steps || []).map(step => typeof step === 'object' ? step.step : step || '')
      ].join(' ');
      
      const japaneseRegex = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/;
      return japaneseRegex.test(textToCheck);
    }

    // 単位を正規化する関数
    function normalizeUnit(unit) {
      if (!unit) return '';
      
      const unitStr = unit.toString().toLowerCase().trim();
      
      // 重複する単位を統一
      const unitMappings = {
        // グラム系
        'grammes': 'g',
        'gramme': 'g',
        'gram': 'g',
        'grams': 'g',
        'グラム': 'g',
        
        // ミリリットル系
        'millilitres': 'ml',
        'millilitre': 'ml',
        'milliliter': 'ml',
        'milliliters': 'ml',
        'ミリリットル': 'ml',
        
        // キログラム系
        'kilogrammes': 'kg',
        'kilogramme': 'kg',
        'kilogram': 'kg',
        'kilograms': 'kg',
        'キログラム': 'kg',
        
        // リットル系
        'litres': 'l',
        'litre': 'l',
        'liter': 'l',
        'liters': 'l',
        'リットル': 'l',
        
        // その他の単位
        'cuillères à soupe': 'tbsp',
        'cuillère à soupe': 'tbsp',
        'cuillères à café': 'tsp',
        'cuillère à café': 'tsp',
        'grandes cuillères': 'tbsp',
        'petites cuillères': 'tsp',
        '大さじ': 'tbsp',
        '小さじ': 'tsp',
        'カップ': 'cup',
        '個': '個',
        'pièce': '個',
        'pièces': '個',
        'pinch': 'つまみ',
        'pincée': 'つまみ',
        'une pincée': 'つまみ'
      };
      
      // マッピングがある場合は変換、ない場合はそのまま
      return unitMappings[unitStr] || unit;
    }

    // 不正なJSONを修正する関数
    function fixMalformedJson(jsonString) {
      try {
        // 基本的なクリーニング
        let fixed = jsonString.trim();
        
        console.log('🔧 JSON修正開始:', {
          original: fixed.substring(0, 200) + '...',
          length: fixed.length
        });
        
        // 不完全な文字列を修正
        // 例: "title": "Glissez cet ingrédient dans votre quiche lorraine si vous souhaitez obtenir la recette authentique",+ → 修正
        fixed = fixed.replace(/",\+/g, '"');
        fixed = fixed.replace(/",\s*\+/g, '"');
        
        // 不正な文字列の終端パターンを修正
        // 例: "description":"L"... → "description":"L..."
        fixed = fixed.replace(/"([^"]*)"\.\.\.([^"}]*)/g, '"$1...$2"');
        
        // 不完全な文字列（引用符が閉じられていない）を修正
        // 例: "title":"Glissez cet ingrédient dans votre quiche lorraine si vous souhaitez obtenir la recette authentique → 修正
        const unclosedStringMatch = fixed.match(/"[^"]*":\s*"[^"]*$/);
        if (unclosedStringMatch) {
          fixed = fixed + '"';
          console.log('🔧 不完全な文字列を修正');
        }
        
        // 配列の修正を強化
        // 不完全な配列項目を修正: {"item": "name", "quantity": "123", "unit": "g → 完全な形に
        fixed = fixed.replace(/\{\s*"item"\s*:\s*"[^"]*"\s*,\s*"quantity"\s*:\s*"[^"]*"\s*,\s*"unit"\s*:\s*"[^"]*$/g, (match) => {
          console.log('🔧 不完全な配列項目を修正:', match);
          return match + '"}';
        });
        
        // 配列の終端修正: [..., → [...]
        fixed = fixed.replace(/,(\s*\])/g, '$1');
        
        // オブジェクトの終端修正: {..., → {...}
        fixed = fixed.replace(/,(\s*\})/g, '$1');
        
        // 不完全な配列を修正
        // "ingredients": [{"item": "name"}, {"item": "name2" → "ingredients": [{"item": "name"}, {"item": "name2"}]
        const incompleteArrayMatch = fixed.match(/"ingredients"\s*:\s*\[[^\]]*$/);
        if (incompleteArrayMatch) {
          console.log('🔧 不完全な配列を検出:', incompleteArrayMatch[0]);
          // 最後の完全なオブジェクトを見つけて配列を閉じる
          const lastCompleteObject = fixed.match(/.*\{[^}]*\}/);
          if (lastCompleteObject) {
            fixed = lastCompleteObject[0] + ']';
            console.log('🔧 配列を強制終了');
          }
        }
        
        // 不完全な手順配列を修正
        const incompleteStepsMatch = fixed.match(/"steps"\s*:\s*\[[^\]]*$/);
        if (incompleteStepsMatch) {
          console.log('🔧 不完全な手順配列を検出');
          // 最後の完全な文字列を見つけて配列を閉じる
          const lastCompleteStep = fixed.match(/.*"[^"]*"/);
          if (lastCompleteStep) {
            fixed = lastCompleteStep[0] + ']';
            console.log('🔧 手順配列を強制終了');
          }
        }
        
        // 不完全なオブジェクトの終端を修正
        if (!fixed.endsWith('}') && !fixed.endsWith(']')) {
          console.log('🔧 不完全なオブジェクト終端を検出');
          
          // 最後の完全なプロパティを見つける
          const patterns = [
            /"[^"]*":\s*"[^"]*"/, // "key": "value"
            /"[^"]*":\s*\[[^\]]*\]/, // "key": [array]
            /"[^"]*":\s*\{[^}]*\}/, // "key": {object}
            /"[^"]*":\s*\d+/, // "key": number
            /"[^"]*":\s*(true|false|null)/ // "key": boolean/null
          ];
          
          let lastCompleteMatch = null;
          for (const pattern of patterns) {
            const matches = fixed.match(new RegExp('.*' + pattern.source));
            if (matches && (!lastCompleteMatch || matches[0].length > lastCompleteMatch[0].length)) {
              lastCompleteMatch = matches;
            }
          }
          
          if (lastCompleteMatch) {
            fixed = lastCompleteMatch[0] + '}';
            console.log('🔧 オブジェクトを強制終了');
          } else {
            // 最低限のJSONオブジェクトを作成
            fixed = '{"title": "JSON解析エラー", "description": "不正なJSONのため解析に失敗しました", "ingredients": [], "steps": []}';
            console.log('🔧 最低限のJSONオブジェクトを作成');
          }
        }
        
        // 二重引用符の問題を修正
        fixed = fixed.replace(/""([^"]*)""/g, '"$1"');
        
        // 特殊文字のエスケープ問題を修正
        fixed = fixed.replace(/\\"/g, '"');
        
        // 最終的な構文チェック
        try {
          JSON.parse(fixed);
          console.log('✅ JSON修正成功');
        } catch (testError) {
          console.warn('⚠️ 修正後もJSON無効:', testError.message);
          // 最後の手段：基本的な構造を強制作成
          fixed = '{"title": "解析エラー", "description": "JSONの修正に失敗しました", "ingredients": [], "steps": []}';
        }
        
        console.log('🔧 JSON修正完了:', {
          fixed: fixed.substring(0, 200) + '...',
          originalLength: jsonString.length,
          fixedLength: fixed.length
        });
        
        return fixed;
      } catch (error) {
        console.error('❌ JSON修正処理エラー:', error);
        return '{"title": "修正エラー", "description": "JSON修正処理でエラーが発生しました", "ingredients": [], "steps": []}';
      }
    }

    // レシピデータを翻訳する関数
    async function translateRecipeData(recipeData) {
      const selectedLanguage = targetLanguageSelect.value;
      const { data, error } = await sb.functions.invoke('call-groq-api', {
        body: {
          mode: 'recipe_translation',
          recipeData: recipeData,
          targetLanguage: selectedLanguage,
          targetLanguageName: '日本語'
        }
      });

      if (error) {
        throw new Error(`翻訳API呼び出しエラー: ${error.message}`);
      }

      if (!data.success) {
        throw new Error(data.error || '翻訳に失敗しました');
      }

      // Groq APIのcontentからJSONを抽出
      const content = data.content || '';
      console.log('🔍 翻訳APIコンテンツ（全体）:', content);
      console.log('🔍 翻訳APIコンテンツ（タイプ）:', typeof content);
      console.log('🔍 翻訳APIコンテンツ（長さ）:', content.length);
      console.log('🔍 翻訳APIレスポンス（data全体）:', data);
      
      try {
        // 複数のJSON抽出パターンを試行
        let translatedData = null;
        
        // パターン1: 完全なJSONオブジェクト
        const jsonMatch1 = content.match(/\{[\s\S]*\}/);
        if (jsonMatch1) {
          try {
            let jsonString = jsonMatch1[0];
            console.log('🔍 パターン1 - 抽出されたJSON文字列:', jsonString);
            
            // JSON修正処理
            jsonString = fixMalformedJson(jsonString);
            console.log('🔧 パターン1 - 修正後のJSON文字列:', jsonString);
            
            translatedData = JSON.parse(jsonString);
            console.log('✅ パターン1でJSON解析成功:', translatedData);
          } catch (e) {
            console.log('❌ パターン1失敗:', e.message);
            console.log('❌ パターン1失敗 - 問題のJSON:', jsonMatch1[0].substring(0, 200));
          }
        }
        
        // パターン2: ```json ブロック内のJSON
        if (!translatedData) {
          const jsonMatch2 = content.match(/```json\s*([\s\S]*?)\s*```/);
          if (jsonMatch2) {
            try {
              let jsonString = jsonMatch2[1].trim();
              console.log('🔍 パターン2 - 抽出されたJSON文字列:', jsonString);
              
              jsonString = fixMalformedJson(jsonString);
              translatedData = JSON.parse(jsonString);
              console.log('✅ パターン2でJSON解析成功:', translatedData);
            } catch (e) {
              console.log('❌ パターン2失敗:', e.message);
            }
          }
        }
        
        // パターン3: ``` ブロック内のJSON
        if (!translatedData) {
          const jsonMatch3 = content.match(/```\s*([\s\S]*?)\s*```/);
          if (jsonMatch3) {
            try {
              translatedData = JSON.parse(jsonMatch3[1]);
              console.log('✅ パターン3でJSON解析成功:', translatedData);
            } catch (e) {
              console.log('❌ パターン3失敗:', e.message);
            }
          }
        }
        
        // パターン4: 最初と最後の{}を探す
        if (!translatedData) {
          const firstBrace = content.indexOf('{');
          const lastBrace = content.lastIndexOf('}');
          if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
            try {
              let jsonString = content.substring(firstBrace, lastBrace + 1);
              console.log('🔍 パターン4 - 抽出されたJSON文字列:', jsonString);
              
              jsonString = fixMalformedJson(jsonString);
              translatedData = JSON.parse(jsonString);
              console.log('✅ パターン4でJSON解析成功:', translatedData);
            } catch (e) {
              console.log('❌ パターン4失敗:', e.message);
            }
          }
        }
        
        // パターン5: 行ごとに{}を探す
        if (!translatedData) {
          const lines = content.split('\n');
          for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
              try {
                let jsonString = fixMalformedJson(trimmed);
                translatedData = JSON.parse(jsonString);
                console.log('✅ パターン5でJSON解析成功:', translatedData);
                break;
              } catch (e) {
                console.log('❌ パターン5失敗（行）:', e.message);
              }
            }
          }
        }
        
        if (translatedData) {
          console.log('✅ 翻訳データ取得成功:', translatedData);
          console.log('🔍 翻訳データの構造:', {
            hasTitle: !!translatedData.title,
            hasDescription: !!translatedData.description,
            hasServings: !!translatedData.servings,
            hasIngredients: !!translatedData.ingredients,
            hasSteps: !!translatedData.steps,
            ingredientsLength: translatedData.ingredients?.length || 0,
            stepsLength: translatedData.steps?.length || 0
          });
          return translatedData;
        } else {
          // フォールバック: レスポンスが自然言語の場合、手動で構造化データを作成
          console.warn('⚠️ JSON解析に失敗、自然言語レスポンスから構造化データを作成します');
          
          // 自然言語レスポンスから基本的な情報を抽出
          const fallbackData = {
            title: currentRecipeData?.title ? `${currentRecipeData.title} (日本語翻訳)` : '翻訳されたレシピ',
            description: content.length > 0 ? content.substring(0, 200) + '...' : '翻訳情報が取得できませんでした',
            servings: currentRecipeData?.servings || '不明',
            ingredients: currentRecipeData?.ingredients || [],
            steps: currentRecipeData?.steps || []
          };
          
          console.log('📝 フォールバックデータ:', fallbackData);
          return fallbackData;
        }
        
      } catch (parseError) {
        console.error('❌ 翻訳JSON解析エラー:', parseError);
        throw new Error(`翻訳データの解析に失敗しました: ${parseError.message}`);
      }
    }

    // 包括的なレシピ構造解析関数
    function parseComplexRecipeStructure(recipeData, url = '') {
      const r = recipeData || {};
      
      console.log('🔍 包括的レシピ構造解析開始');
      console.log('📊 入力データ:', r);
      console.log('📊 手順数:', r.steps?.length || 0);
      console.log('📊 材料数:', r.ingredients?.length || 0);
      console.log('📊 URL:', url);
      
      // サイト別特別処理の検出
      const siteDetection = {
        valrhona: url && url.includes('valrhona.com'),
        marmiton: url && url.includes('marmiton.org'),
        cookpad: url && url.includes('cookpad.com'),
        kurashiru: url && url.includes('kurashiru.com'),
        delishkitchen: url && url.includes('delishkitchen.tv'),
        gibier: url && url.includes('gibier.or.jp'),
        tsuji: url && url.includes('tsuji.ac.jp'),
        professional: url && (url.includes('chef') || url.includes('hotel') || url.includes('restaurant'))
      };
      
      console.log('🏷️ サイト検出結果:', siteDetection);
      
      // セクション構造を検出
      const sections = [];
      
      // Valrhonaサイトの場合は専用処理を優先
      if (siteDetection.valrhona && r.ingredients && r.ingredients.length > 0) {
        console.log('🏷️ Valrhona専用処理を実行');
        console.log('📊 入力材料リスト詳細:');
        r.ingredients.forEach((ing, index) => {
          console.log(`  ${index + 1}. ${typeof ing === 'string' ? ing : `${ing.item || ing.name || '?'} - ${ing.quantity || '?'} ${ing.unit || '?'}`}`);
        });
        
        // Valrhonaの既知のセクション構造を使用
        const valrhonaSections = [
          { title: 'LIQUID STARCH', weight: '495g' },
          { title: 'JIVARA 40% INTENSE WHIPPED GANACHE', weight: '1003g' },
          { title: 'SWEET & SAVORY CANDIED NUT MIX', weight: '177g' },
          { title: 'BEER SYRUP FOR BABAS', weight: '3000g' },
          { title: 'BABA DOUGH', weight: '599g' }
        ];
        
        const valrhonaMapping = createValrhonaIngredientMapping(r.ingredients);
        
        valrhonaSections.forEach((sectionInfo) => {
          const sectionIngredients = valrhonaMapping[sectionInfo.title] || [];
          
          if (sectionIngredients.length > 0) {
            sections.push({
              title: sectionInfo.title,
              totalWeight: sectionInfo.weight,
              ingredients: sectionIngredients,
              instructions: []
            });
            
            console.log(`✅ Valrhonaセクション作成: "${sectionInfo.title}" - 材料数: ${sectionIngredients.length}`);
          } else {
            console.log(`❌ 空のセクション: "${sectionInfo.title}" - 材料数: 0`);
          }
        });
        
        console.log('🏁 Valrhona専用処理完了 - セクション数:', sections.length);
        
        // 総材料数の確認
        const totalMapped = Object.values(valrhonaMapping).reduce((sum, sectionItems) => sum + sectionItems.length, 0);
        console.log(`📊 マッピング統計: 元材料${r.ingredients.length}個 → マッピング済み${totalMapped}個`);
        
        if (totalMapped < r.ingredients.length) {
          console.warn(`⚠️ 未マッピング材料あり: ${r.ingredients.length - totalMapped}個が抜けています`);
        }
      }
      
      // ジビエ・日本語プロレシピの場合は専用処理
      if (sections.length === 0 && (siteDetection.gibier || siteDetection.tsuji || siteDetection.professional)) {
        console.log('🏷️ 日本語プロレシピ専用処理を実行');
        const japaneseProfessionalSections = createJapaneseProfessionalSections(r, url);
        if (japaneseProfessionalSections.length > 0) {
          console.log('✅ 日本語プロレシピ処理成功:', japaneseProfessionalSections.length, '個');
          sections.push(...japaneseProfessionalSections);
        }
      }
      
      // Valrhona以外または専用処理が失敗した場合の一般的な処理
      if (sections.length === 0) {
        // 1. 手順からセクションを抽出する方法を試行
        console.log('🔍 方法1: 手順からセクション抽出を試行');
        const extractedSections = extractSectionsFromSteps(r, siteDetection);
        if (extractedSections.length > 0) {
          console.log('✅ 手順からセクション抽出成功:', extractedSections.length, '個');
          sections.push(...extractedSections);
        }
        
        // 2. 材料名から料理の工程を推測する方法
        if (sections.length === 0) {
          console.log('🔍 方法2: 材料からカテゴリ推測を試行');
          const inferredSections = inferSectionsFromIngredients(r);
          if (inferredSections.length > 0) {
            console.log('✅ 材料からセクション推測成功:', inferredSections.length, '個');
            sections.push(...inferredSections);
          }
        }
        
        // 3. レシピの複雑さに基づく自動分割
        if (sections.length === 0 && r.ingredients && r.ingredients.length > 8) {
          console.log('🔍 方法3: 複雑レシピの自動分割を試行');
          const autoSections = createAutoSections(r);
          if (autoSections.length > 0) {
            console.log('✅ 自動分割成功:', autoSections.length, '個');
            sections.push(...autoSections);
          }
        }
      }
      
      // 手順からセクションを抽出
      if (r.steps && r.steps.length > 0) {
        let currentSection = null;
        
        r.steps.forEach((step, index) => {
          const stepText = typeof step === 'string' ? step : (step.step || step.instruction || '');
          console.log(`\n🔍 Step ${index + 1} 解析開始:`);
          console.log(`📝 ステップテキスト（全体）:`, stepText);
          console.log(`📝 ステップテキスト（最初の200文字）:`, stepText.substring(0, 200));
          
          // セクションタイトル検出パターンを複数試行
          let sectionMatch = null;
          let detectedTitle = null;
          
          // パターン1: Valrhona Step形式 "Step01 LIQUID STARCH" または "Step02 JIVARA 40% INTENSE WHIPPED GANACHE"
          const stepPattern = /^Step\s*(\d+)\s*(.+?)(?:\n|$)/i;
          const stepMatch = stepText.match(stepPattern);
          if (stepMatch && stepMatch[2]) {
            detectedTitle = stepMatch[2].trim();
            sectionMatch = stepMatch;
            console.log('🎯 Step形式検出:', detectedTitle);
          } else {
            console.log('❌ Step形式マッチなし');
          }
          
          // パターン2: 大文字タイトル行 "LIQUID STARCH" または "JIVARA 40% INTENSE WHIPPED GANACHE"
          if (!sectionMatch) {
            const titlePattern = /^([A-Z][A-Z\s&%0-9]{3,})(?:\n|$)/;
            const titleMatch = stepText.match(titlePattern);
            if (titleMatch) {
              detectedTitle = titleMatch[1].trim();
              sectionMatch = titleMatch;
              console.log('🎯 大文字タイトル検出:', detectedTitle);
            } else {
              console.log('❌ 大文字タイトルマッチなし');
            }
          }
          
          // パターン3: 番号付きタイトル "1. LIQUID STARCH"
          if (!sectionMatch) {
            const numberedPattern = /^(\d+\.?\s*)([A-Z][A-Z\s&%0-9]{3,})(?:\n|$)/;
            const numberedMatch = stepText.match(numberedPattern);
            if (numberedMatch) {
              detectedTitle = numberedMatch[2].trim();
              sectionMatch = numberedMatch;
              console.log('🎯 番号付きタイトル検出:', detectedTitle);
            } else {
              console.log('❌ 番号付きタイトルマッチなし');
            }
          }
          
          // パターン4: 行内の大文字セクション（改行で区切られていない場合）
          if (!sectionMatch) {
            const inlinePattern = /([A-Z][A-Z\s&%0-9]{4,})/g;
            const inlineMatches = stepText.match(inlinePattern);
            if (inlineMatches && inlineMatches.length > 0) {
              // 最初の大文字セクションを使用
              detectedTitle = inlineMatches[0].trim();
              sectionMatch = { 0: detectedTitle };
              console.log('🎯 行内大文字セクション検出:', detectedTitle);
            } else {
              console.log('❌ 行内大文字セクションマッチなし');
            }
          }
          
          console.log(`🔍 最終検出結果: ${detectedTitle ? `"${detectedTitle}"` : 'なし'}`);
          
          if (sectionMatch && detectedTitle && detectedTitle.length >= 4) {
            // 新しいセクション開始
            if (currentSection) {
              console.log('📝 セクション完了:', currentSection.title, `材料数: ${currentSection.ingredients.length}`);
              sections.push(currentSection);
            }
            
            currentSection = {
              title: detectedTitle,
              ingredients: [],
              instructions: [],
              totalWeight: null
            };
            
            console.log('🆕 新セクション開始:', detectedTitle);
          } else {
            console.log('❌ セクション検出失敗 - 既存セクションに追加');
          }
          
          if (currentSection) {
            console.log('🔍 現在のセクション:', currentSection.title);
            
            // 重量情報を抽出（複数パターン対応）
            const weightPatterns = [
              /(\d+g)\s*Total weight/i,
              /Total weight[:\s]*(\d+g)/i,
              /^(\d+g)$/
            ];
            
            for (const pattern of weightPatterns) {
              const weightMatch = stepText.match(pattern);
              if (weightMatch) {
                currentSection.totalWeight = weightMatch[1];
                console.log('⚖️ 重量検出:', weightMatch[1]);
                break;
              }
            }
            
            // 材料を抽出（行ごとに処理）
            const lines = stepText.split('\n');
            console.log('📋 行数:', lines.length);
            
            lines.forEach((line, lineIndex) => {
              const trimmedLine = line.trim();
              if (!trimmedLine) return;
              
              console.log(`  📝 行 ${lineIndex + 1}: "${trimmedLine}"`);
              
              // Valrhona形式の材料パターン: "475g Liquid starch"
              const valrhonaIngredient = trimmedLine.match(/^(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+(.+)$/);
              if (valrhonaIngredient) {
                const quantity = valrhonaIngredient[1];
                const unit = normalizeUnit(valrhonaIngredient[2]);
                const item = valrhonaIngredient[3].trim();
                
                console.log(`    🔍 Valrhona材料候補: "${item}" - ${quantity} ${unit}`);
                
                // セクションタイトルや重量情報でないことを確認
                if (!item.match(/^(Step|STEP|\d+g\s*Total|Total\s*weight)/i) && item.length >= 2) {
                  currentSection.ingredients.push({
                    quantity: quantity,
                    unit: unit,
                    item: item
                  });
                  console.log('    ✅ Valrhona材料追加:', `${item} - ${quantity} ${unit}`);
                } else {
                  console.log('    ❌ Valrhona材料除外（タイトル/重量）:', item);
                }
                return;
              }
              
              // 一般形式の材料パターン: "Liquid starch - 475g"
              const generalIngredient = trimmedLine.match(/^(.+?)\s*[-–]\s*(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)$/);
              if (generalIngredient) {
                const item = generalIngredient[1].trim();
                const quantity = generalIngredient[2];
                const unit = normalizeUnit(generalIngredient[3]);
                
                console.log(`    🔍 一般材料候補: "${item}" - ${quantity} ${unit}`);
                
                if (item.length >= 2) {
                  currentSection.ingredients.push({
                    quantity: quantity,
                    unit: unit,
                    item: item
                  });
                  console.log('    ✅ 一般材料追加:', `${item} - ${quantity} ${unit}`);
                } else {
                  console.log('    ❌ 一般材料除外（短すぎ）:', item);
                }
                return;
              }
              
              // 新パターン: 手順内の材料抽出 "475g liquid starch", "320g JIVARA 40%"など
              const inlineIngredients = trimmedLine.match(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+([a-zA-Z\s%0-9]+)/g);
              if (inlineIngredients) {
                console.log(`    🔍 手順内材料検出: ${inlineIngredients.length}個`);
                inlineIngredients.forEach((match, matchIndex) => {
                  const ingredientMatch = match.match(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+(.+)/);
                  if (ingredientMatch) {
                    const quantity = ingredientMatch[1];
                    const unit = normalizeUnit(ingredientMatch[2]);
                    const item = ingredientMatch[3].trim();
                    
                    console.log(`      🔍 手順内材料 ${matchIndex + 1}: "${item}" - ${quantity} ${unit}`);
                    
                    // 材料として適切かチェック（一般的な材料名）
                    const isValidIngredient = item.match(/^(liquid starch|jivara|gelatin|water|heavy cream|sugar|beer|flour|eggs|yeast|butter|milk|potato starch|glucose|candied|nuts|pistachios|hazelnuts|kasha)/i);
                    
                    if (isValidIngredient && item.length >= 3) {
                      currentSection.ingredients.push({
                        quantity: quantity,
                        unit: unit,
                        item: item
                      });
                      console.log(`      ✅ 手順内材料追加: ${item} - ${quantity} ${unit}`);
                    } else {
                      console.log(`      ❌ 手順内材料除外: ${item} (材料名として不適切)`);
                    }
                  }
                });
                return;
              }
              
              console.log('    ❌ 材料パターンマッチなし');
            });
            
            console.log(`🥄 現在の材料数: ${currentSection.ingredients.length}`);
            
            // 手順テキストを追加（セクションタイトルと材料を除く）
            let cleanInstruction = stepText
              .replace(/^(Step\s*\d+[\s\n]*)?([A-Z][A-Z\s&%0-9]+)(?:[\s\n])/i, '')
              .replace(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+([A-Za-z\s,()&\-'0-9]+)/g, '')
              .replace(/(\d+g)\s*Total weight/i, '')
              .trim();
            
            if (cleanInstruction && cleanInstruction.length > 10) {
              currentSection.instructions.push(cleanInstruction);
              console.log('📋 手順追加:', cleanInstruction.substring(0, 50) + '...');
            }
          } else {
            console.log('⚠️ currentSectionがnull - セクション未検出');
          }
        });
        
        // 最後のセクションを追加
        if (currentSection) {
          console.log('📝 最終セクション完了:', currentSection.title, `材料数: ${currentSection.ingredients.length}`);
          sections.push(currentSection);
        }
      } else {
        console.log('⚠️ 手順データなし');
      }
      
      console.log('🏁 解析完了 - 総セクション数:', sections.length);
      sections.forEach((section, index) => {
        console.log(`  セクション ${index + 1}: "${section.title}" - 材料数: ${section.ingredients.length}`);
      });
      
      // 最終的なフォールバック処理
      if (sections.length === 0) {
        console.log('⚠️ 全ての抽出方法が失敗 - 基本構造を作成');
        sections.push({
          title: 'INGREDIENTS',
          ingredients: r.ingredients ? r.ingredients.map(ingredient => normalizeIngredientObject(ingredient)) : [],
          instructions: r.steps || [],
          totalWeight: null
        });
      } else {
        // セクションは見つかったが材料が抽出できていない場合、元の材料リストを分配
        const totalIngredients = sections.reduce((sum, section) => sum + (section.ingredients?.length || 0), 0);
        console.log('🔍 総材料数チェック:', totalIngredients);
        
        if (totalIngredients === 0 && r.ingredients && r.ingredients.length > 0) {
          console.log('⚠️ セクション内材料なし - 智能分配を実行');
          console.log('📊 元材料リスト:', r.ingredients);
          
          // 材料の意味に基づく智能分配
          const smartMapping = createSmartIngredientMapping(r.ingredients, sections);
          
          sections.forEach((section, sectionIndex) => {
            if (smartMapping[section.title]) {
              section.ingredients = smartMapping[section.title];
              console.log(`📋 智能分配: "${section.title}" に材料 ${section.ingredients.length} 個を配置`);
            }
          });
        }
      }
      
      return sections;
    }

    // 手順からセクションを抽出する関数
    function extractSectionsFromSteps(recipeData, siteDetection) {
      const r = recipeData || {};
      const sections = [];
      
      if (!r.steps || r.steps.length === 0) return sections;
      
      let currentSection = null;
      
      r.steps.forEach((step, index) => {
        const stepText = typeof step === 'string' ? step : (step.step || step.instruction || '');
        
        // 包括的なセクションタイトル検出パターン
        const sectionPatterns = [
          // Valrhona形式: "Step01 LIQUID STARCH"
          /^Step\s*(\d+)\s*(.+?)(?:\n|$)/i,
          // 一般的な番号付きセクション: "1. Preparation", "2. Dough Making"
          /^(\d+)\.?\s*([A-Z][A-Za-z\s&%0-9]{4,})(?:\n|$)/i,
          // 大文字タイトル: "LIQUID STARCH", "PREPARATION"
          /^([A-Z][A-Z\s&%0-9]{4,})(?:\n|$)/i,
          // 括弧付きセクション: "(1) Preparation", "[Step 1] Mixing"
          /^[\(\[\{]?(?:Step\s*)?(\d+)[\)\]\}]?\s*([A-Za-z][A-Za-z\s&%0-9]{4,})(?:\n|$)/i,
          // 日本語セクション: "1. 下準備", "2. 生地作り"
          /^(\d+)\.?\s*([\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]{3,})(?:\n|$)/i
        ];
        
        let detectedTitle = null;
        let sectionMatch = null;
        
        for (const pattern of sectionPatterns) {
          const match = stepText.match(pattern);
          if (match) {
            detectedTitle = (match[2] || match[1]).trim();
            sectionMatch = match;
            console.log(`🎯 セクション検出 (パターン${sectionPatterns.indexOf(pattern) + 1}):`, detectedTitle);
            break;
          }
        }
        
        if (sectionMatch && detectedTitle && detectedTitle.length >= 3) {
          // 新しいセクション開始
          if (currentSection) {
            sections.push(currentSection);
          }
          
          currentSection = {
            title: detectedTitle,
            ingredients: [],
            instructions: [],
            totalWeight: null
          };
        }
        
        if (currentSection) {
          // 材料抽出の強化
          extractIngredientsFromStep(stepText, currentSection);
          
          // 重量情報抽出
          const weightMatch = stepText.match(/(\d+g)\s*Total weight|Total weight[:\s]*(\d+g)|^(\d+g)$/i);
          if (weightMatch) {
            currentSection.totalWeight = weightMatch[1] || weightMatch[2] || weightMatch[3];
          }
          
          // 手順テキストの追加
          const cleanInstruction = cleanStepText(stepText);
          if (cleanInstruction && cleanInstruction.length > 10) {
            currentSection.instructions.push(cleanInstruction);
          }
        }
      });
      
      if (currentSection) {
        sections.push(currentSection);
      }
      
      return sections;
    }

    // 材料から料理工程を推測する関数
    function inferSectionsFromIngredients(recipeData) {
      const r = recipeData || {};
      if (!r.ingredients || r.ingredients.length < 6) return [];
      
      const sections = [];
      const ingredientCategories = categorizeIngredients(r.ingredients);
      
      // カテゴリ別にセクションを作成
      Object.entries(ingredientCategories).forEach(([category, ingredients]) => {
        if (ingredients.length > 0) {
          sections.push({
            title: category,
            ingredients: ingredients,
            instructions: [],
            totalWeight: null
          });
        }
      });
      
      return sections;
    }

    // 材料をカテゴリ別に分類する関数（日本語対応強化版）
    function categorizeIngredients(ingredients) {
      const categories = {
        'ベース材料 / BASE': [],
        'フィリング・ソース / FILLING': [],
        'トッピング・飾り / TOPPINGS': [],
        '調味料・香料 / SEASONINGS': [],
        'その他 / OTHERS': []
      };
      
      console.log('🔍 材料カテゴリ分類開始:', ingredients.length, '個');
      
      ingredients.forEach((ingredient, index) => {
        const normalizedIng = normalizeIngredientObject(ingredient);
        const itemName = normalizedIng.item.toLowerCase();
        
        console.log(`🔍 材料 ${index + 1}: "${normalizedIng.item}"`);
        
        // 生地・ベース材料（日本語・英語対応）
        if (itemName.match(/flour|bread|dough|starch|yeast|egg|milk|butter|oil|sugar|water|小麦粉|薄力粉|強力粉|卵|牛乳|バター|砂糖|水|ベーキングパウダー|イースト|生地/)) {
          categories['ベース材料 / BASE'].push(normalizedIng);
          console.log(`  → ベース材料 に分類`);
        }
        // ソース・フィリング（日本語・英語対応）
        else if (itemName.match(/cream|sauce|chocolate|ganache|filling|syrup|jam|paste|クリーム|チョコ|ソース|ジャム|シロップ|ガナッシュ|あん|餡/)) {
          categories['フィリング・ソース / FILLING'].push(normalizedIng);
          console.log(`  → フィリング・ソース に分類`);
        }
        // トッピング（日本語・英語対応）
        else if (itemName.match(/nuts|seeds|fruits?|berries|sprinkles|decoration|topping|ナッツ|種|実|果物|フルーツ|飾り|トッピング|粉糖|シナモン|ココア/)) {
          categories['トッピング・飾り / TOPPINGS'].push(normalizedIng);
          console.log(`  → トッピング・飾り に分類`);
        }
        // 調味料（日本語・英語対応）
        else if (itemName.match(/salt|pepper|spice|herb|vanilla|extract|seasoning|塩|胡椒|こしょう|醤油|味噌|酢|みりん|酒|香料|エッセンス|バニラ|スパイス/)) {
          categories['調味料・香料 / SEASONINGS'].push(normalizedIng);
          console.log(`  → 調味料・香料 に分類`);
        }
        // かぼちゃ系（特別分類）
        else if (itemName.match(/pumpkin|squash|かぼちゃ|南瓜|マッシュ/)) {
          categories['ベース材料 / BASE'].push(normalizedIng);
          console.log(`  → ベース材料 に分類 (かぼちゃ系)`);
        }
        // その他
        else {
          categories['その他 / OTHERS'].push(normalizedIng);
          console.log(`  → その他 に分類`);
        }
      });
      
      // 空のカテゴリを削除
      Object.keys(categories).forEach(key => {
        if (categories[key].length === 0) {
          delete categories[key];
        }
      });
      
      console.log('📋 分類結果:');
      Object.entries(categories).forEach(([category, items]) => {
        console.log(`  ${category}: ${items.length}個`);
      });
      
      return categories;
    }

    // 複雑なレシピの自動分割
    function createAutoSections(recipeData) {
      const r = recipeData || {};
      if (!r.ingredients || r.ingredients.length < 8) return [];
      
      const sections = [];
      const sectionSize = Math.ceil(r.ingredients.length / 3); // 3分割を基本とする
      
      const sectionNames = ['PREPARATION', 'MAIN PROCESS', 'FINISHING'];
      
      for (let i = 0; i < 3; i++) {
        const startIndex = i * sectionSize;
        const endIndex = Math.min(startIndex + sectionSize, r.ingredients.length);
        const sectionIngredients = r.ingredients.slice(startIndex, endIndex);
        
        if (sectionIngredients.length > 0) {
          sections.push({
            title: sectionNames[i],
            ingredients: sectionIngredients.map(ingredient => normalizeIngredientObject(ingredient)),
            instructions: [],
            totalWeight: null
          });
        }
      }
      
      return sections;
    }

    // 手順テキストから材料を抽出する強化版
    function extractIngredientsFromStep(stepText, section) {
      const lines = stepText.split('\n');
      
      lines.forEach(line => {
        const trimmedLine = line.trim();
        if (!trimmedLine) return;
        
        // 複数の材料パターンを試行
        const patterns = [
          // "475g Liquid starch"
          /^(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+(.+)$/,
          // "Liquid starch - 475g"
          /^(.+?)\s*[-–]\s*(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)$/,
          // "2 cups flour"
          /^(\d+(?:\.\d+)?)\s+(cups?|tbsp|tsp|pieces?)\s+(.+)$/i,
          // 日本語パターン: "小麦粉 200g"
          /^([\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)\s*(\d+(?:\.\d+)?)\s*([a-zA-Zｇｍｌ%]+)$/
        ];
        
        for (const pattern of patterns) {
          const match = trimmedLine.match(pattern);
          if (match) {
            let item, quantity, unit;
            
            if (pattern === patterns[0]) { // "475g Liquid starch"
              [, quantity, unit, item] = match;
            } else if (pattern === patterns[1]) { // "Liquid starch - 475g"
              [, item, quantity, unit] = match;
            } else if (pattern === patterns[2]) { // "2 cups flour"
              [, quantity, unit, item] = match;
            } else if (pattern === patterns[3]) { // 日本語
              [, item, quantity, unit] = match;
            }
            
            // 有効な材料かチェック
            if (item && item.length >= 2 && !item.match(/^(Step|STEP|\d+g\s*Total|Total\s*weight)/i)) {
              section.ingredients.push({
                item: item.trim(),
                quantity: quantity || '',
                unit: normalizeUnit(unit || '')
              });
              break;
            }
          }
        }
      });
    }

    // 手順テキストをクリーニングする関数
    function cleanStepText(stepText) {
      return stepText
        .replace(/^(Step\s*\d+[\s\n]*)?([A-Z][A-Z\s&%0-9]+)(?:[\s\n])/i, '')
        .replace(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+([A-Za-z\s,()&\-'0-9]+)/g, '')
        .replace(/(\d+g)\s*Total weight/i, '')
        .trim();
    }

    // 日本語プロレシピ専用のセクション作成関数
    function createJapaneseProfessionalSections(recipeData, url = '') {
      console.log('🏷️ 日本語プロレシピセクション作成開始');
      
      const r = recipeData || {};
      const ingredients = r.ingredients || [];
      const steps = r.steps || [];
      const title = r.title || '';
      
      console.log('📊 日本語プロレシピ分析:');
      console.log(`  タイトル: "${title}"`);
      console.log(`  材料数: ${ingredients.length}`);
      console.log(`  手順数: ${steps.length}`);
      
      const sections = [];
      
      // ジビエレシピの場合の特別処理
      const isGibierRecipe = title.match(/鹿|猪|いのしし|ジビエ|ウェリントン|wellington/i) ||
                            ingredients.some(ing => {
                              const itemName = typeof ing === 'string' ? ing : (ing.item || ing.name || '');
                              return itemName.match(/鹿|猪|いのしし|ジビエ|venison|wild.*boar/i);
                            });
      
      if (isGibierRecipe) {
        console.log('🦌 ジビエレシピ検出 - 専用セクション作成');
        
        // 手順から工程を検出
        const detectedProcesses = [];
        const allText = `${title} ${steps.join(' ')}`;
        
        // ジビエ料理の典型的な工程パターン
        const processPatterns = [
          { pattern: /マリナード|マリネ|漬け込み|下味/i, section: 'マリナード・下準備' },
          { pattern: /ウェリントン|パイ包み|パイ生地/i, section: 'ウェリントン包み' },
          { pattern: /コンフィ|低温調理|真空/i, section: 'コンフィ・付け合わせ' },
          { pattern: /ドフィノワーズ|グラタン|ベシャメル/i, section: 'ドフィノワーズ' },
          { pattern: /ソース|燻煙|醤油|柚子/i, section: 'ソース・調味料' },
          { pattern: /フリカッセ|きのこ|茸|マッシュルーム/i, section: 'フリカッセ・ガルニ' },
          { pattern: /ジェノベーゼ|ワサビ|香草/i, section: 'ハーブ・薬味' },
          { pattern: /盛り付け|仕上げ|飾り/i, section: '盛り付け・仕上げ' }
        ];
        
        processPatterns.forEach(({ pattern, section }) => {
          if (pattern.test(allText)) {
            detectedProcesses.push(section);
            console.log(`  工程検出: ${section}`);
          }
        });
        
        // 材料を工程別に分類
        if (detectedProcesses.length > 0) {
          detectedProcesses.forEach(processName => {
            const sectionIngredients = [];
            
            ingredients.forEach(ingredient => {
              const normalizedIngredient = normalizeIngredientObject(ingredient);
              const itemName = normalizedIngredient.item.toLowerCase();
              
              // 工程別材料分類ルール（大幅強化）
              let shouldInclude = false;
              
              switch (processName) {
                case 'マリナード・下準備':
                  shouldInclude = itemName.match(/鹿|ロース|肉|味噌|香草|塩|コショウ|pepper|salt|miso|marinade|marinate|下味|漬け込み/i);
                  break;
                case 'ウェリントン包み':
                  shouldInclude = itemName.match(/パイ|シート|キャベツ|卵黄|pastry|puff|cabbage|egg|wellington|包み|生地|粒生黒コショウ|フルール.*セル/i);
                  break;
                case 'コンフィ・付け合わせ':
                  shouldInclude = itemName.match(/白ネギ|ねぎ|オリーブオイル|ニンニク|タイム|ローリエ|leek|olive|garlic|thyme|bay|confit|ごぼう|パンチェッタ|玉ネギ|無塩バター|チキンブイヨン|白コショウ/i);
                  break;
                case 'ドフィノワーズ':
                  shouldInclude = itemName.match(/サツマイモ|ジャガイモ|生クリーム|牛乳|パルメザン|potato|cream|milk|parmesan|dauphinoise|ベシャメル|薄力粉|ナツメグ/i);
                  break;
                case 'ソース・調味料':
                  shouldInclude = itemName.match(/醤油|燻煙|柚子|バター|ブイヨン|コーンスターチ|soy|yuzu|butter|stock|cornstarch|焦がしバター|燻煙醬油|柚子果汁/i);
                  break;
                case 'フリカッセ・ガルニ':
                  shouldInclude = itemName.match(/ジロル|トランペット|芽キャベツ|きのこ|茸|mushroom|brussels|fricassee|ドライトランペット|エシャロット|サラダ油/i);
                  break;
                case 'ハーブ・薬味':
                  shouldInclude = itemName.match(/ワサビ|わさび|香草|パセリ|wasabi|herb|parsley|ジェノベーゼ|genovese|ピーテンドリル|マイクロアマランサス/i);
                  break;
                case '盛り付け・仕上げ':
                  shouldInclude = itemName.match(/飾り|ガルニ|マイクロ|garnish|micro|盛り付け|仕上げ|decoration/i);
                  break;
              }
              
              // より包括的な材料マッチング（部分一致も考慮）
              if (!shouldInclude) {
                // 材料名に含まれるキーワードで再チェック
                const keywords = itemName.split(/\s+|・|、|,/);
                keywords.forEach(keyword => {
                  if (keyword.length >= 2) { // 2文字以上のキーワードのみ
                    switch (processName) {
                      case 'マリナード・下準備':
                        if (keyword.match(/鹿|肉|味噌|香草|塩|胡椒/i)) shouldInclude = true;
                        break;
                      case 'ウェリントン包み':
                        if (keyword.match(/パイ|キャベツ|卵|生地|黒胡椒|セル/i)) shouldInclude = true;
                        break;
                      case 'コンフィ・付け合わせ':
                        if (keyword.match(/ネギ|オリーブ|ニンニク|ごぼう|バター|ブイヨン/i)) shouldInclude = true;
                        break;
                      case 'ドフィノワーズ':
                        if (keyword.match(/イモ|芋|クリーム|牛乳|チーズ|小麦粉/i)) shouldInclude = true;
                        break;
                      case 'ソース・調味料':
                        if (keyword.match(/醤油|柚子|バター|ソース|調味/i)) shouldInclude = true;
                        break;
                      case 'フリカッセ・ガルニ':
                        if (keyword.match(/きのこ|茸|キャベツ|エシャロット/i)) shouldInclude = true;
                        break;
                      case 'ハーブ・薬味':
                        if (keyword.match(/ワサビ|香草|ハーブ|パセリ/i)) shouldInclude = true;
                        break;
                    }
                  }
                });
              }
              
              if (shouldInclude) {
                sectionIngredients.push(normalizedIngredient);
                console.log(`    材料分類: "${normalizedIngredient.item}" → ${processName}`);
              }
            });
            
            if (sectionIngredients.length > 0) {
              sections.push({
                title: processName,
                ingredients: sectionIngredients,
                instructions: [],
                totalWeight: null
              });
            }
          });
        }
      }
      
      // 一般的な日本語プロレシピの場合
      if (sections.length === 0) {
        console.log('🍳 一般日本語プロレシピ処理');
        
        // 材料を基本的なカテゴリに分類
        const basicCategories = {
          '主材料': [],
          '調味料・ソース': [],
          '付け合わせ': [],
          '仕上げ・飾り': []
        };
        
        ingredients.forEach(ingredient => {
          const normalizedIngredient = normalizeIngredientObject(ingredient);
          const itemName = normalizedIngredient.item.toLowerCase();
          
          // 基本分類ルール
          if (itemName.match(/肉|魚|鶏|豚|牛|鹿|猪|meat|fish|chicken|pork|beef|venison/i)) {
            basicCategories['主材料'].push(normalizedIngredient);
          } else if (itemName.match(/醤油|味噌|塩|砂糖|酢|油|ソース|バター|soy|miso|salt|sugar|vinegar|oil|sauce|butter/i)) {
            basicCategories['調味料・ソース'].push(normalizedIngredient);
          } else if (itemName.match(/野菜|きのこ|芋|ネギ|キャベツ|vegetable|mushroom|potato|leek|cabbage/i)) {
            basicCategories['付け合わせ'].push(normalizedIngredient);
          } else if (itemName.match(/飾り|香草|スパイス|garnish|herb|spice/i)) {
            basicCategories['仕上げ・飾り'].push(normalizedIngredient);
          } else {
            // デフォルトは主材料に
            basicCategories['主材料'].push(normalizedIngredient);
          }
        });
        
        // 空でないカテゴリのみセクションとして追加
        Object.entries(basicCategories).forEach(([categoryName, categoryIngredients]) => {
          if (categoryIngredients.length > 0) {
            sections.push({
              title: categoryName,
              ingredients: categoryIngredients,
              instructions: [],
              totalWeight: null
            });
          }
        });
      }
      
      console.log('🏁 日本語プロレシピセクション作成完了:', sections.length, '個');
      sections.forEach((section, index) => {
        console.log(`  セクション ${index + 1}: "${section.title}" - 材料数: ${section.ingredients.length}`);
      });
      
      return sections;
    }

    // Valrhona専用の材料マッピング関数（改良版）
    function createValrhonaIngredientMapping(ingredients) {
      const mapping = {
        'LIQUID STARCH': [],
        'JIVARA 40% INTENSE WHIPPED GANACHE': [],
        'SWEET & SAVORY CANDIED NUT MIX': [],
        'BEER SYRUP FOR BABAS': [],
        'BABA DOUGH': []
      };
      
      console.log('🔍 Valrhona材料マッピング開始:', ingredients.length, '個の材料');
      
      ingredients.forEach((ingredient, index) => {
        const normalizedIngredient = normalizeIngredientObject(ingredient);
        const itemName = normalizedIngredient.item.toLowerCase();
        const quantity = parseInt(normalizedIngredient.quantity) || 0;
        
        console.log(`🔍 材料 ${index + 1}: "${normalizedIngredient.item}" - ${normalizedIngredient.quantity} ${normalizedIngredient.unit}`);
        
        // より包括的で精密な分類ルール
        let classified = false;
        
        // LIQUID STARCH セクション
        if (itemName.match(/liquid\s*starch/) || itemName.includes('starch')) {
          mapping['LIQUID STARCH'].push(normalizedIngredient);
          console.log(`  → LIQUID STARCH に分類 (starch関連)`);
          classified = true;
        }
        
        // JIVARA GANACHE セクション
        if (itemName.match(/jivara/) || 
            itemName.match(/chocolate|ganache/) ||
            (itemName.includes('heavy cream') && quantity >= 190) ||
            itemName.match(/gelatin|gelatine/)) {
          mapping['JIVARA 40% INTENSE WHIPPED GANACHE'].push(normalizedIngredient);
          console.log(`  → JIVARA GANACHE に分類 (${itemName.includes('jivara') ? 'jivara' : itemName.includes('cream') ? 'heavy cream' : itemName.includes('gelatin') ? 'gelatin' : 'chocolate関連'})`);
          classified = true;
        }
        
        // CANDIED NUT MIX セクション
        if (itemName.match(/hazelnut|pistachio|kasha|nuts|candied|roasted.*piedmont|blanched.*sicilian/)) {
          mapping['SWEET & SAVORY CANDIED NUT MIX'].push(normalizedIngredient);
          console.log(`  → CANDIED NUT MIX に分類 (ナッツ関連: ${itemName})`);
          classified = true;
        }
        
        // BEER SYRUP セクション
        if (itemName.includes('beer') ||
           (itemName.includes('sugar') && quantity >= 755) ||
           (itemName.includes('water') && quantity >= 605) ||
           itemName.includes('glucose') ||
           itemName.includes('milk') && quantity > 100) {
          mapping['BEER SYRUP FOR BABAS'].push(normalizedIngredient);
          console.log(`  → BEER SYRUP に分類 (${itemName.includes('beer') ? 'beer' : itemName.includes('glucose') ? 'glucose' : itemName.includes('milk') ? 'milk' : itemName.includes('sugar') ? `sugar ${quantity}g` : `water ${quantity}g`})`);
          classified = true;
        }
        
        // BABA DOUGH セクション
        if (itemName.match(/flour|strong.*flour/) ||
           itemName.match(/egg|whole.*egg/) ||
           itemName.match(/yeast|live.*yeast/) ||
           itemName.match(/butter|european.*style.*butter/) ||
           itemName.match(/lemon|candied.*lemon|diced.*candied/) ||
           itemName.includes('fleur de sel') ||
           itemName.includes('sel') ||
           (itemName.includes('sugar') && quantity <= 55) ||
           (itemName.includes('water') && quantity <= 320 && itemName.includes('gelatin'))) {
          mapping['BABA DOUGH'].push(normalizedIngredient);
          console.log(`  → BABA DOUGH に分類 (${itemName.includes('flour') ? 'flour' : itemName.includes('egg') ? 'egg' : itemName.includes('yeast') ? 'yeast' : itemName.includes('butter') ? 'butter' : itemName.includes('lemon') ? 'lemon' : itemName.includes('sel') ? 'sel' : itemName.includes('sugar') ? `sugar ${quantity}g` : `water for gelatin`})`);
          classified = true;
        }
        
        // 未分類の処理
        if (!classified) {
          console.warn(`⚠️ 未分類材料: "${normalizedIngredient.item}" - ${quantity}${normalizedIngredient.unit}`);
          
          // 数量に基づく推測
          if (itemName.includes('water')) {
            if (quantity <= 320) {
              mapping['BABA DOUGH'].push(normalizedIngredient);
              console.log(`  → BABA DOUGH に分類 (少量水: ${quantity}g)`);
            } else {
              mapping['BEER SYRUP FOR BABAS'].push(normalizedIngredient);
              console.log(`  → BEER SYRUP に分類 (大量水: ${quantity}g)`);
            }
          } else if (itemName.includes('sugar')) {
            if (quantity <= 100) {
              mapping['BABA DOUGH'].push(normalizedIngredient);
              console.log(`  → BABA DOUGH に分類 (少量砂糖: ${quantity}g)`);
            } else {
              mapping['BEER SYRUP FOR BABAS'].push(normalizedIngredient);
              console.log(`  → BEER SYRUP に分類 (大量砂糖: ${quantity}g)`);
            }
          } else {
            // 最後の手段: LIQUID STARCHに分類
            mapping['LIQUID STARCH'].push(normalizedIngredient);
            console.log(`  → LIQUID STARCH に分類 (デフォルト: ${itemName})`);
          }
        }
      });
      
      // 各セクションの材料数をログ出力
      Object.entries(mapping).forEach(([section, ingredients]) => {
        console.log(`📋 ${section}: ${ingredients.length}個の材料`);
        ingredients.forEach((ing, index) => {
          console.log(`  ${index + 1}. ${ing.item} - ${ing.quantity} ${ing.unit}`);
        });
      });
      
      return mapping;
    }

    // 一般的なレシピ用の智能材料分配関数
    function createSmartIngredientMapping(ingredients, sections) {
      const mapping = {};
      
      // 各セクションを初期化
      sections.forEach(section => {
        mapping[section.title] = [];
      });
      
      console.log('🧠 智能材料分配開始:', ingredients.length, '個の材料を', sections.length, '個のセクションに分配');
      
      ingredients.forEach((ingredient, index) => {
        const normalizedIngredient = normalizeIngredientObject(ingredient);
        const itemName = normalizedIngredient.item.toLowerCase();
        
        let assigned = false;
        
        // セクション名に基づく分配
        sections.forEach(section => {
          const sectionName = section.title.toLowerCase();
          
          // キーワードマッチング
          const keywords = extractKeywords(sectionName);
          const ingredientKeywords = extractKeywords(itemName);
          
          // 共通キーワードがある場合は優先的に分配
          const commonKeywords = keywords.filter(k => 
            ingredientKeywords.some(ik => ik.includes(k) || k.includes(ik))
          );
          
          if (commonKeywords.length > 0 && !assigned) {
            mapping[section.title].push(normalizedIngredient);
            console.log(`🎯 キーワードマッチ: "${normalizedIngredient.item}" → "${section.title}" (共通: ${commonKeywords.join(', ')})`);
            assigned = true;
          }
        });
        
        // マッチしなかった場合は最初のセクションに分配
        if (!assigned && sections.length > 0) {
          mapping[sections[0].title].push(normalizedIngredient);
          console.log(`📍 デフォルト分配: "${normalizedIngredient.item}" → "${sections[0].title}"`);
        }
      });
      
      return mapping;
    }

    // テキストからキーワードを抽出する関数
    function extractKeywords(text) {
      return text.toLowerCase()
        .split(/[\s\-_&%]+/)
        .filter(word => word.length > 2)
        .map(word => word.replace(/[^a-z0-9]/g, ''));
    }

    // 材料オブジェクトを正規化する関数
    function normalizeIngredientObject(ingredient) {
      if (typeof ingredient === 'string') {
        const match = ingredient.match(/^(.+?)\s*[-–]\s*(.+)$/);
        if (match) {
          const item = match[1].trim();
          const quantityUnit = match[2].trim();
          const quantityMatch = quantityUnit.match(/^(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)$/);
          if (quantityMatch) {
            return {
              item: item,
              quantity: quantityMatch[1],
              unit: normalizeUnit(quantityMatch[2])
            };
          }
        }
        return { item: ingredient, quantity: '', unit: '' };
      } else {
        return {
          item: ingredient.item || ingredient.name || '',
          quantity: ingredient.quantity || ingredient.amount || '',
          unit: normalizeUnit(ingredient.unit || '')
        };
      }
    }

    // レシピの複雑さを解析してカテゴリ別表示が適切かを判断
    function analyzeRecipeComplexity(recipeData, url = '') {
      console.log('🔍 レシピ複雑度解析開始');
      
      const r = recipeData || {};
      const ingredients = r.ingredients || [];
      const steps = r.steps || [];
      const title = r.title || '';
      
      console.log('📊 基本統計:');
      console.log(`  材料数: ${ingredients.length}`);
      console.log(`  手順数: ${steps.length}`);
      console.log(`  タイトル: "${title}"`);
      
      // 1. 材料数が少ない場合はシンプル表示（基準を緩和）
      if (ingredients.length < 5) {
        console.log('❌ 材料数が少ない (< 5) - シンプル表示');
        return false;
      }
      
      // 2. 手順からセクション構造を検出（日本語パターン強化）
      const stepsText = steps.join(' ').toLowerCase();
      const sectionIndicators = [
        // 英語パターン
        /for\s+the\s+\w+/g,
        /\b(dough|batter|cream|sauce|filling|ganache|syrup|mixture|wellington|confit|fricassee|duxelles)\b/g,
        /step\s+\d+:/g,
        /part\s+\d+/g,
        // 日本語パターン（強化）
        /【.*?】/g,
        /■.*?■/g,
        /\d+\.\s*【/g,
        /工程\s*\d+/g,
        /手順\s*\d+/g,
        /①|②|③|④|⑤|⑥|⑦|⑧|⑨|⑩/g,
        /を作る|を準備|下準備|仕上げ|盛り付け/g,
        /ソース|生地|フィリング|トッピング|ガルニ/g
      ];
      
      let sectionCount = 0;
      sectionIndicators.forEach(pattern => {
        const matches = stepsText.match(pattern);
        if (matches) {
          sectionCount += matches.length;
          console.log(`  セクション指標発見: ${pattern} - ${matches.length}個`);
        }
      });
      
      // 3. 材料名から複雑度を判定（日本語・ジビエ料理対応強化）
      const complexIngredientPatterns = [
        // 専門的な材料（西洋）
        /ganache|couverture|valrhona|callebaut/i,
        /glucose|invert\s+sugar|isomalt/i,
        /gellan|agar|pectin|xanthan/i,
        // 複数の調理工程を示唆する材料
        /tempered|melted|whipped|clarified/i,
        /reduction|infusion|extract/i,
        // 日本語の専門材料（強化）
        /ガナッシュ|クーベルチュール|転化糖|アガー|ゼラチン/i,
        /生クリーム.*?泡立て|バター.*?溶かし/i,
        // ジビエ・高級食材
        /鹿|猪|いのしし|ジビエ|venison|wild\s+boar/i,
        /フォアグラ|トリュフ|キャビア|foie\s+gras|truffle|caviar/i,
        // フランス料理技法
        /ウェリントン|wellington|コンフィ|confit|フリカッセ|fricassee/i,
        /ドフィノワーズ|dauphinoise|ベシャメル|bechamel|デュクセル|duxelles/i,
        /ジュノベーゼ|genovese|フルール.*?セル|fleur.*?sel/i,
        // 高級調味料・材料
        /パルメザン|parmesan|グリュイエール|gruyere/i,
        /エシャロット|shallot|マデラ|madeira|ポルト|port/i,
        /燻製|スモーク|smoke|燻煙/i,
        // 専門器具・技法を示唆
        /真空|vacuum|低温|sous\s+vide/i,
        /コンベクション|convection|スチーム|steam/i
      ];
      
      let complexIngredientCount = 0;
      const allText = `${title} ${ingredients.map(ing => 
        typeof ing === 'string' ? ing : (ing.item || ing.name || '')
      ).join(' ')} ${steps.join(' ')}`;
      
      complexIngredientPatterns.forEach(pattern => {
        const matches = allText.match(pattern);
        if (matches) {
          complexIngredientCount += matches.length;
          console.log(`  複雑材料/技法発見: ${matches.join(', ')}`);
        }
      });
      
      // 4. プロレシピ・コンテスト入賞作品の検出
      const professionalIndicators = [
        /コンテスト|contest|competition|入賞|受賞|award/i,
        /シェフ|chef|料理長|パティシエ|patissier/i,
        /ホテル|hotel|レストラン|restaurant/i,
        /プロ部門|professional|プロフェッショナル/i,
        /ミシュラン|michelin|星付き/i
      ];
      
      let professionalScore = 0;
      professionalIndicators.forEach(pattern => {
        if (pattern.test(allText)) {
          professionalScore += 2;
          console.log(`  プロ指標発見: ${pattern}`);
        }
      });
      
      // 5. 総合判定（基準を緩和）
      const complexityScore = sectionCount * 1.5 + complexIngredientCount + professionalScore;
      console.log('📊 複雑度スコア計算:');
      console.log(`  セクション数: ${sectionCount} × 1.5 = ${sectionCount * 1.5}`);
      console.log(`  複雑材料数: ${complexIngredientCount}`);
      console.log(`  プロ指標: ${professionalScore}`);
      console.log(`  総合スコア: ${complexityScore}`);
      
      // 6. 特定サイトは優先的にカテゴリ表示（日本語サイト追加）
      const isComplexSite = url && (
        url.includes('valrhona.com') ||
        url.includes('marmiton.org') ||
        url.includes('chef') ||
        url.includes('professional') ||
        url.includes('patisserie') ||
        url.includes('gibier.or.jp') ||
        url.includes('tsuji.ac.jp') ||
        url.includes('cordonbleu') ||
        url.includes('hotel') ||
        url.includes('restaurant')
      );
      
      if (isComplexSite) {
        console.log('✅ 複雑サイト検出 - カテゴリ表示適用');
        return true;
      }
      
      // 7. 材料数による判定（基準緩和）
      const hasManyIngredients = ingredients.length >= 8;
      const hasProfessionalElements = professionalScore > 0 || complexIngredientCount > 0;
      
      // 8. 最終判定（基準を大幅に緩和）
      const shouldCategorize = 
        complexityScore >= 2 || 
        (ingredients.length >= 8 && sectionCount > 0) ||
        (ingredients.length >= 12) ||
        (hasProfessionalElements && ingredients.length >= 6);
        
      console.log(`${shouldCategorize ? '✅' : '❌'} 最終判定: ${shouldCategorize ? 'カテゴリ表示' : 'シンプル表示'}`);
      console.log('📋 判定理由:');
      console.log(`  複雑度スコア >= 2: ${complexityScore >= 2} (${complexityScore})`);
      console.log(`  材料8個以上 + セクション: ${ingredients.length >= 8 && sectionCount > 0} (材料:${ingredients.length}, セクション:${sectionCount})`);
      console.log(`  材料12個以上: ${ingredients.length >= 12} (${ingredients.length})`);
      console.log(`  プロ要素 + 材料6個以上: ${hasProfessionalElements && ingredients.length >= 6} (プロ:${hasProfessionalElements}, 材料:${ingredients.length})`);
      
      return shouldCategorize;
    }

    // 材料専用のフレキシブル表示関数
    function displayFlexibleIngredients(recipeData, containerId, url = '') {
      const container = document.getElementById(containerId);
      if (!container) {
        console.error('❌ コンテナが見つかりません:', containerId);
        return;
      }
      
      console.log('🎯 材料表示開始:', containerId);
      console.log('📊 URL:', url);
      
      // レシピ構造を解析してカテゴリ別表示が適切かを判断
      const shouldUseCategorization = analyzeRecipeComplexity(recipeData, url);
      
      console.log('🏷️ カテゴリ別表示適用判定:', shouldUseCategorization);
      
      if (!shouldUseCategorization) {
        console.log('📝 シンプル表示を使用');
        displaySimpleIngredients(recipeData, containerId);
        return;
      }
      
      console.log('🔧 カテゴリ別表示を試行');
      console.log('📊 レシピデータ:', recipeData);
      console.log('📊 レシピデータの構造:', {
        hasTitle: !!recipeData?.title,
        hasIngredients: !!recipeData?.ingredients,
        hasSteps: !!recipeData?.steps,
        ingredientsLength: recipeData?.ingredients?.length || 0,
        stepsLength: recipeData?.steps?.length || 0
      });
      
      const sections = parseComplexRecipeStructure(recipeData, url);
      console.log('📋 解析されたセクション数:', sections.length);
      console.log('📋 各セクションの詳細:');
      sections.forEach((section, index) => {
        console.log(`  セクション ${index + 1}: "${section.title}" - 材料数: ${section.ingredients?.length || 0}`);
        if (section.ingredients && section.ingredients.length > 0) {
          section.ingredients.forEach((ing, ingIndex) => {
            console.log(`    材料 ${ingIndex + 1}: ${ing.item} - ${ing.quantity} ${ing.unit}`);
          });
        }
      });
      
      container.innerHTML = '';
      let displayedSections = 0;
      
      // 材料セクションのみを表示
      sections.forEach((section, index) => {
        console.log(`🔍 セクション ${index + 1} 処理中:`, section.title, `材料数: ${section.ingredients?.length || 0}`);
        
        if (section.ingredients && section.ingredients.length > 0) {
          const sectionDiv = document.createElement('div');
          sectionDiv.className = 'recipe-section';
          
          // セクションタイトル
          const titleDiv = document.createElement('div');
          titleDiv.className = 'recipe-section-title';
          titleDiv.textContent = section.title;
          sectionDiv.appendChild(titleDiv);
          console.log('📝 セクションタイトル設定:', section.title);
          
          // 総重量
          if (section.totalWeight) {
            const weightDiv = document.createElement('div');
            weightDiv.className = 'recipe-section-weight';
            weightDiv.textContent = `Total weight: ${section.totalWeight}`;
            sectionDiv.appendChild(weightDiv);
            console.log('⚖️ 重量表示:', section.totalWeight);
          }
          
          // 材料グリッド
          section.ingredients.forEach((ingredient, ingredientIndex) => {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'recipe-ingredients-grid';
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'ingredient-name';
            nameDiv.textContent = ingredient.item || ingredient.name || '';
            
            const quantityDiv = document.createElement('div');
            quantityDiv.className = 'ingredient-quantity';
            quantityDiv.textContent = ingredient.quantity || '';
            
            const unitDiv = document.createElement('div');
            unitDiv.className = 'ingredient-unit';
            unitDiv.textContent = ingredient.unit || '';
            
            gridDiv.appendChild(nameDiv);
            gridDiv.appendChild(quantityDiv);
            gridDiv.appendChild(unitDiv);
            sectionDiv.appendChild(gridDiv);
            
            console.log(`🥄 材料 ${ingredientIndex + 1} 追加:`, `${ingredient.item} - ${ingredient.quantity} ${ingredient.unit}`);
          });
          
          container.appendChild(sectionDiv);
          displayedSections++;
          console.log('✅ セクション表示完了:', section.title);
        } else {
          console.log('⚠️ 材料なしセクション:', section.title);
        }
      });
      
      console.log(`🏁 フレキシブル表示完了 - 表示セクション数: ${displayedSections}`);
      
      // セクション化された材料が見つからない場合は従来の表示
      if (displayedSections === 0) {
        console.log('⚠️ カテゴリ化材料なし - シンプル表示にフォールバック');
        console.log('📊 フォールバック理由調査:');
        console.log('  - セクション数:', sections.length);
        sections.forEach((section, index) => {
          console.log(`  - セクション ${index + 1}: "${section.title}" 材料数: ${section.ingredients?.length || 0}`);
        });
        displaySimpleIngredients(recipeData, containerId);
      } else {
        console.log('✅ カテゴリ別表示成功！');
      }
    }
    
    // シンプルな材料表示関数（フォールバック用）
    function displaySimpleIngredients(recipeData, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      const r = recipeData || {};
      container.innerHTML = '';
      
      if (r.ingredients && r.ingredients.length > 0) {
        r.ingredients.forEach(ingredient => {
          const item = document.createElement('div');
          item.className = 'ingredient-item';
          
          // 材料の表示形式を改善（分量のダブりを防ぐ）
          let ingredientText = '';
          if (typeof ingredient === 'string') {
            ingredientText = ingredient;
          } else if (ingredient && typeof ingredient === 'object') {
            const itemName = ingredient.item || ingredient.name || '';
            const quantity = ingredient.quantity || ingredient.amount || '';
            const rawUnit = ingredient.unit || '';
            
            // 単位を正規化
            const unit = normalizeUnit(rawUnit);
            
            // 分量と単位を組み合わせ（数値と単位の間にスペース）
            const quantityUnit = [quantity, unit].filter(Boolean).join(' ');
            
            // 材料名と分量を組み合わせ
            ingredientText = [itemName, quantityUnit].filter(Boolean).join(' - ');
          }
          
          item.textContent = ingredientText || '材料情報なし';
          container.appendChild(item);
        });
      } else if (r.ingredientLines && r.ingredientLines.length > 0) {
        r.ingredientLines.forEach(line => {
          const item = document.createElement('div');
          item.className = 'ingredient-item';
          item.textContent = line;
          container.appendChild(item);
        });
      } else {
        const item = document.createElement('div');
        item.className = 'ingredient-item';
        item.textContent = '材料が見つかりませんでした';
        container.appendChild(item);
      }
    }

    // フレキシブルなレシピ表示関数
    function displayFlexibleRecipe(recipeData, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      const sections = parseComplexRecipeStructure(recipeData);
      
      container.innerHTML = '';
      
      sections.forEach(section => {
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'recipe-section';
        
        // セクションタイトル
        const titleDiv = document.createElement('div');
        titleDiv.className = 'recipe-section-title';
        titleDiv.textContent = section.title;
        sectionDiv.appendChild(titleDiv);
        
        // 総重量
        if (section.totalWeight) {
          const weightDiv = document.createElement('div');
          weightDiv.className = 'recipe-section-weight';
          weightDiv.textContent = `Total weight: ${section.totalWeight}`;
          sectionDiv.appendChild(weightDiv);
        }
        
        // 材料グリッド
        if (section.ingredients && section.ingredients.length > 0) {
          section.ingredients.forEach(ingredient => {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'recipe-ingredients-grid';
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'ingredient-name';
            nameDiv.textContent = ingredient.item || ingredient.name || '';
            
            const quantityDiv = document.createElement('div');
            quantityDiv.className = 'ingredient-quantity';
            quantityDiv.textContent = ingredient.quantity || '';
            
            const unitDiv = document.createElement('div');
            unitDiv.className = 'ingredient-unit';
            unitDiv.textContent = ingredient.unit || '';
            
            gridDiv.appendChild(nameDiv);
            gridDiv.appendChild(quantityDiv);
            gridDiv.appendChild(unitDiv);
            sectionDiv.appendChild(gridDiv);
          });
        }
        
        // 手順
        if (section.instructions && section.instructions.length > 0) {
          const instructionsDiv = document.createElement('div');
          instructionsDiv.className = 'recipe-instructions';
          
          section.instructions.forEach(instruction => {
            const p = document.createElement('p');
            p.textContent = instruction;
            instructionsDiv.appendChild(p);
          });
          
          sectionDiv.appendChild(instructionsDiv);
        }
        
        container.appendChild(sectionDiv);
      });
    }

    // 翻訳結果を表示する関数
    function displayTranslatedResults(translatedData) {
      const t = translatedData || {};
      
      console.log('🖼️ 翻訳結果表示開始:', t);
      console.log('🖼️ 翻訳データのキー:', Object.keys(t));
      
      // タイトル
      const titleText = t.title || '(翻訳なし)';
      document.getElementById('translatedRecipeTitle').textContent = titleText;
      console.log('🖼️ タイトル設定:', titleText);
      
      // 説明
      const descriptionText = t.description || '(翻訳なし)';
      document.getElementById('translatedRecipeDescription').textContent = descriptionText;
      console.log('🖼️ 説明設定:', descriptionText);
      
      // 人数
      const servingsText = t.servings || '(翻訳なし)';
      document.getElementById('translatedRecipeServings').textContent = servingsText;
      console.log('🖼️ 人数設定:', servingsText);
      
      // 材料（フレキシブル翻訳表示）
      console.log('🖼️ 翻訳材料データ:', t.ingredients);
      console.log('🖼️ 翻訳材料データタイプ:', typeof t.ingredients);
      console.log('🖼️ 翻訳材料データ長さ:', t.ingredients?.length);
      
      // 翻訳後も元のセクション構造を維持
      console.log('🌐 翻訳時のセクション構造維持処理開始');
      displayTranslatedIngredientsWithStructure(t, currentRecipeData, 'flexibleTranslatedIngredientsDisplay');
      
      // 手順
      const translatedStepsList = document.getElementById('translatedStepsList');
      translatedStepsList.innerHTML = '';
      
      console.log('🖼️ 手順データ:', t.steps);
      console.log('🖼️ 手順データタイプ:', typeof t.steps);
      console.log('🖼️ 手順データ長さ:', t.steps?.length);
      
      if (t.steps && t.steps.length > 0) {
        t.steps.forEach((step, index) => {
          const item = document.createElement('div');
          item.className = 'step-item';
          
          // 手順の表示形式を改善（連番のダブりを防ぐ）
          let stepText = '';
          if (typeof step === 'string') {
            stepText = step;
          } else if (step && typeof step === 'object') {
            stepText = step.step || step.instruction || step.text || '';
          }
          
          // 既に番号が付いているかチェック
          const hasNumber = /^\d+\.?\s/.test(stepText.trim());
          
          if (hasNumber) {
            // 既に番号が付いている場合はそのまま表示
            item.textContent = stepText;
          } else {
            // 番号が付いていない場合は番号を追加
            item.textContent = `${index + 1}. ${stepText}`;
          }
          
          translatedStepsList.appendChild(item);
          console.log(`🖼️ 手順${index + 1}設定:`, item.textContent);
        });
      } else {
        const item = document.createElement('div');
        item.className = 'step-item';
        item.textContent = '翻訳された手順がありません';
        translatedStepsList.appendChild(item);
        console.log('🖼️ 手順なしメッセージ表示');
      }
    }

    // 翻訳材料の構造維持表示関数
    function displayTranslatedIngredientsWithStructure(translatedData, originalData, containerId) {
      const container = document.getElementById(containerId);
      if (!container) {
        console.error('❌ 翻訳用コンテナが見つかりません:', containerId);
        return;
      }
      
      console.log('🌐 翻訳構造維持表示開始');
      console.log('📊 翻訳データ:', translatedData);
      console.log('📊 元データ:', originalData);
      
      // 元のレシピ構造を取得（既に解析済みの構造を再利用）
      const url = window.lastProcessedUrl || '';
      const isValrhonaSite = url.includes('valrhona.com');
      
      if (isValrhonaSite && originalData && originalData.ingredients) {
        console.log('🏷️ Valrhona翻訳: 元構造を維持して翻訳材料をマッピング');
        
        // 元のValrhonaマッピングを再実行
        const originalMapping = createValrhonaIngredientMapping(originalData.ingredients);
        console.log('📋 元のマッピング:', originalMapping);
        
        // 翻訳材料を元の構造にマッピング
        const translatedMapping = mapTranslatedIngredientsToOriginalStructure(
          translatedData.ingredients || [],
          originalData.ingredients || [],
          originalMapping
        );
        
        // Valrhonaセクションで表示
        const valrhonaSections = [
          { title: 'LIQUID STARCH', titleJa: '液体澱粉', weight: '495g' },
          { title: 'JIVARA 40% INTENSE WHIPPED GANACHE', titleJa: 'ジヴァラ40% インテンス ホイップガナッシュ', weight: '1003g' },
          { title: 'SWEET & SAVORY CANDIED NUT MIX', titleJa: 'スイート&セイボリー キャンディードナッツミックス', weight: '177g' },
          { title: 'BEER SYRUP FOR BABAS', titleJa: 'ババ用ビールシロップ', weight: '3000g' },
          { title: 'BABA DOUGH', titleJa: 'ババ生地', weight: '599g' }
        ];
        
        container.innerHTML = '';
        
        valrhonaSections.forEach((sectionInfo) => {
          const sectionIngredients = translatedMapping[sectionInfo.title] || [];
          
          if (sectionIngredients.length > 0) {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'recipe-section';
            
            // セクションタイトル（日本語）
            const titleDiv = document.createElement('div');
            titleDiv.className = 'recipe-section-title';
            titleDiv.textContent = sectionInfo.titleJa;
            sectionDiv.appendChild(titleDiv);
            
            // 総重量
            const weightDiv = document.createElement('div');
            weightDiv.className = 'recipe-section-weight';
            weightDiv.textContent = `Total weight: ${sectionInfo.weight}`;
            sectionDiv.appendChild(weightDiv);
            
            // 材料グリッド
            sectionIngredients.forEach((ingredient) => {
              const gridDiv = document.createElement('div');
              gridDiv.className = 'recipe-ingredients-grid';
              
              const nameDiv = document.createElement('div');
              nameDiv.className = 'ingredient-name';
              nameDiv.textContent = ingredient.item || '';
              
              const quantityDiv = document.createElement('div');
              quantityDiv.className = 'ingredient-quantity';
              quantityDiv.textContent = ingredient.quantity || '';
              
              const unitDiv = document.createElement('div');
              unitDiv.className = 'ingredient-unit';
              unitDiv.textContent = ingredient.unit || '';
              
              gridDiv.appendChild(nameDiv);
              gridDiv.appendChild(quantityDiv);
              gridDiv.appendChild(unitDiv);
              sectionDiv.appendChild(gridDiv);
            });
            
            container.appendChild(sectionDiv);
            console.log(`✅ 翻訳セクション表示: "${sectionInfo.titleJa}" - 材料数: ${sectionIngredients.length}`);
          }
        });
        
        console.log('🌐 Valrhona翻訳構造表示完了');
      } else {
        console.log('⚠️ 非Valrhonaサイト: 通常の翻訳表示');
        displayFlexibleIngredients(translatedData, containerId, '');
      }
    }

    // 翻訳材料を元の構造にマッピングする関数
    function mapTranslatedIngredientsToOriginalStructure(translatedIngredients, originalIngredients, originalMapping) {
      const mapping = {
        'LIQUID STARCH': [],
        'JIVARA 40% INTENSE WHIPPED GANACHE': [],
        'SWEET & SAVORY CANDIED NUT MIX': [],
        'BEER SYRUP FOR BABAS': [],
        'BABA DOUGH': []
      };
      
      console.log('🔗 翻訳材料マッピング開始');
      console.log('📊 翻訳材料数:', translatedIngredients.length);
      console.log('📊 元材料数:', originalIngredients.length);
      
      // 翻訳材料を順番に元の構造に対応付け
      translatedIngredients.forEach((translatedIng, index) => {
        const normalizedTranslated = normalizeIngredientObject(translatedIng);
        
        // 対応する元の材料を見つける（インデックスベース）
        if (index < originalIngredients.length) {
          const originalIng = originalIngredients[index];
          
          // 元の材料がどのセクションに分類されていたかを調べる
          let foundSection = null;
          Object.entries(originalMapping).forEach(([sectionName, sectionIngredients]) => {
            if (sectionIngredients.some(ing => 
              ing.item === (typeof originalIng === 'string' ? originalIng : originalIng.item))) {
              foundSection = sectionName;
            }
          });
          
          if (foundSection) {
            mapping[foundSection].push(normalizedTranslated);
            console.log(`🔗 マッピング: "${normalizedTranslated.item}" → ${foundSection}`);
          } else {
            // フォールバック: 最初のセクションに追加
            mapping['LIQUID STARCH'].push(normalizedTranslated);
            console.log(`🔗 フォールバック: "${normalizedTranslated.item}" → LIQUID STARCH`);
          }
        }
      });
      
      return mapping;
    }

    // サイトの言語を判定する関数
    function detectSiteLanguage(html, url) {
      console.log('🔍 サイト言語判定開始:', url);
      
      // URLベースの判定
      const urlIndicators = {
        japanese: ['.jp', 'cookpad.com', 'kurashiru.com', 'delishkitchen.tv', 'japanese', 'japan', 'rakuten-recipe.jp'],
        english: ['.com', '.org', '.net', '.edu', '.gov', '.uk', '.au', '.ca'],
        french: ['.fr', 'marmiton.org', 'cuisine.fr', 'elle.fr/cuisine'],
        italian: ['.it', 'giallozafferano.it', 'ricette.it'],
        german: ['.de', 'chefkoch.de', 'essen-und-trinken.de'],
        spanish: ['.es', 'recetasgratis.net', 'directoalpaladar.com']
      };
      
      let detectedLanguage = { code: 'en', name: 'English', isJapanese: false };
      
      // URLから言語を判定
      for (const [lang, indicators] of Object.entries(urlIndicators)) {
        if (indicators.some(indicator => url && url.toLowerCase().includes(indicator))) {
          switch (lang) {
            case 'japanese':
              detectedLanguage = { code: 'ja', name: 'Japanese', isJapanese: true };
              break;
            case 'french':
              detectedLanguage = { code: 'fr', name: 'French', isJapanese: false };
              break;
            case 'italian':
              detectedLanguage = { code: 'it', name: 'Italian', isJapanese: false };
              break;
            case 'german':
              detectedLanguage = { code: 'de', name: 'German', isJapanese: false };
              break;
            case 'spanish':
              detectedLanguage = { code: 'es', name: 'Spanish', isJapanese: false };
              break;
            default:
              detectedLanguage = { code: 'en', name: 'English', isJapanese: false };
          }
          console.log('🌐 URL判定結果:', lang, '→', detectedLanguage);
          break;
        }
      }
      
      // HTMLコンテンツから言語を判定（URLベース判定を補強）
      const japaneseRegex = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/;
      const frenchRegex = /\b(recette|ingrédients|préparation|cuisson|pour|avec|dans|une|des|les|temps|min)\b/i;
      const italianRegex = /\b(ricetta|ingredienti|preparazione|cottura|per|con|in|una|dei|gli|tempo|min)\b/i;
      const germanRegex = /\b(rezept|zutaten|zubereitung|kochen|für|mit|in|eine|der|die|zeit|min)\b/i;
      const spanishRegex = /\b(receta|ingredientes|preparación|cocción|para|con|en|una|los|las|tiempo|min)\b/i;
      
      if (japaneseRegex.test(html)) {
        detectedLanguage = { code: 'ja', name: 'Japanese', isJapanese: true };
        console.log('🇯🇵 日本語文字検出 → Japanese');
      } else if (frenchRegex.test(html)) {
        detectedLanguage = { code: 'fr', name: 'French', isJapanese: false };
        console.log('🇫🇷 フランス語キーワード検出 → French');
      } else if (italianRegex.test(html)) {
        detectedLanguage = { code: 'it', name: 'Italian', isJapanese: false };
        console.log('🇮🇹 イタリア語キーワード検出 → Italian');
      } else if (germanRegex.test(html)) {
        detectedLanguage = { code: 'de', name: 'German', isJapanese: false };
        console.log('🇩🇪 ドイツ語キーワード検出 → German');
      } else if (spanishRegex.test(html)) {
        detectedLanguage = { code: 'es', name: 'Spanish', isJapanese: false };
        console.log('🇪🇸 スペイン語キーワード検出 → Spanish');
      }
      
      console.log('🏁 最終言語判定:', detectedLanguage);
      return detectedLanguage;
    }

    // レシピ抽出プロンプトを生成する関数
    function generateRecipeExtractionPrompt(htmlContent, url, siteLanguage = { code: 'en', name: 'English', isJapanese: false }) {
      console.log('📝 プロンプト生成開始:', {
        url: url,
        siteLanguage: siteLanguage,
        contentLength: htmlContent.length
      });
      
      // 言語別にプロンプトを生成
      if (siteLanguage.isJapanese) {
        // 日本語サイト用のプロンプト（Recipe Keeper.app最適化版）
        return `以下のHTMLコンテンツから日本語レシピを解析し、JSON形式で構造化してください。

【Recipe Keeper最適化指示】
- 高速処理に特化した簡潔な解析
- 材料リストの正確な抽出を優先
- 分量・単位の分離に重点
- 日本語文字エンコーディングの保護
- 不要な説明文は最小限に

【日本語処理要件】
1. ひらがな・カタカナ・漢字を正確に抽出
2. UTF-8エンコーディングを維持
3. 日本語特有の分量表記を認識（大さじ、小さじ、カップ、つまみ等）
4. 文字化けを防止

【入力HTML】
${htmlContent.substring(0, 8000)}

【出力形式】
{
  "title": "レシピ名",
  "description": "簡潔な説明",
  "servings": "人数",
  "ingredients": [
    {"item": "材料名", "quantity": "分量", "unit": "単位"}
  ],
  "steps": ["手順1", "手順2"],
  "notes": "メモ"
}

【材料抽出例】
- 小麦粉 100g → {"item": "小麦粉", "quantity": "100", "unit": "g"}
- 卵 1個 → {"item": "卵", "quantity": "1", "unit": "個"}
- 大さじ2の醤油 → {"item": "醤油", "quantity": "2", "unit": "大さじ"}
- 適量の塩 → {"item": "塩", "quantity": "適量", "unit": ""}
- バター 15g → {"item": "バター", "quantity": "15", "unit": "g"}
- 牛乳 200ml → {"item": "牛乳", "quantity": "200", "unit": "ml"}
- 砂糖 30g → {"item": "砂糖", "quantity": "30", "unit": "g"}

【分量・単位抽出の重要ルール】
1. 材料名、分量、単位を必ず分離してください
2. 分量は数値のみ（"100"）、単位は文字のみ（"g"）
3. 全角数字は半角に変換してください
4. 日本語単位も正確に抽出（大さじ、小さじ、カップ、個、枚、本）
5. 適量、少々、お好みなどは分量フィールドに入れてください
6. 価格情報（円）があれば別途抽出してください

【重要】
- 材料は必ずingredients配列に含める
- 分量と単位は正確に分離（最重要）
- 日本語文字を保護
- JSONのみ出力（説明文なし）`;
      } else {
        // 海外サイト用のプロンプト（言語別対応）
        const languageInstructions = {
          'fr': {
            language: 'French',
            keywords: 'recette, ingrédients, préparation',
            example: 'Exemple: "250g de farine" → {"item": "farine", "quantity": "250", "unit": "g"}'
          },
          'it': {
            language: 'Italian', 
            keywords: 'ricetta, ingredienti, preparazione',
            example: 'Esempio: "250g di farina" → {"item": "farina", "quantity": "250", "unit": "g"}'
          },
          'de': {
            language: 'German',
            keywords: 'rezept, zutaten, zubereitung', 
            example: 'Beispiel: "250g Mehl" → {"item": "Mehl", "quantity": "250", "unit": "g"}'
          },
          'es': {
            language: 'Spanish',
            keywords: 'receta, ingredientes, preparación',
            example: 'Ejemplo: "250g de harina" → {"item": "harina", "quantity": "250", "unit": "g"}'
          },
          'en': {
            language: 'English',
            keywords: 'recipe, ingredients, instructions',
            example: 'Example: "250g flour" → {"item": "flour", "quantity": "250", "unit": "g"}'
          }
        };
        
        const langInfo = languageInstructions[siteLanguage.code] || languageInstructions['en'];
        
        return `You are a professional recipe extraction system specialized in ${langInfo.language} content. Extract recipe information from the following HTML content.

LANGUAGE SPECIFIC REQUIREMENTS:
- Detect and preserve ${langInfo.language} text accurately
- Look for keywords like: ${langInfo.keywords}
- Maintain original language in the extracted content
- Handle character encoding properly for ${langInfo.language}

Extract the following recipe information:
- Title (recipe name in original language)
- Description (recipe overview in original language)
- Servings (number of people)
- Ingredients list (separate name, quantity, unit)
- Instructions/steps (in original language)

Output format must be JSON with this structure:
{
  "title": "Recipe title in ${langInfo.language}",
  "description": "Recipe description in ${langInfo.language}",
  "servings": "Number of servings",
  "ingredients": [
    {
      "item": "ingredient name in ${langInfo.language}",
      "quantity": "amount",
      "unit": "unit in ${langInfo.language}"
    }
  ],
  "steps": [
    "Step 1 content in ${langInfo.language}",
    "Step 2 content in ${langInfo.language}"
  ]
}

INGREDIENT EXTRACTION EXAMPLES:
${langInfo.example}
- "250g flour" → {"item": "flour", "quantity": "250", "unit": "g"}
- "2 tbsp olive oil" → {"item": "olive oil", "quantity": "2", "unit": "tbsp"}
- "1 large onion" → {"item": "onion", "quantity": "1", "unit": "large"}
- "Salt to taste" → {"item": "salt", "quantity": "to taste", "unit": ""}

CRITICAL INGREDIENT PARSING RULES:
1. ALWAYS separate ingredient name, quantity, and unit into different fields
2. Quantity should be numbers only ("250", "2", "1")
3. Unit should be text only ("g", "tbsp", "large", "cup")
4. Handle fractions properly ("1/2" → "0.5" or keep as "1/2")
5. Extract "to taste", "as needed" as quantity values
6. Preserve original ${langInfo.language} units and measurements

HTML Content:
${htmlContent.substring(0, 8000)}

IMPORTANT: 
- Return only valid JSON (no explanatory text)
- Preserve original ${langInfo.language} text
- Ensure proper character encoding
- Separate ingredients into item, quantity, and unit fields accurately (MOST IMPORTANT)`;
      }
    }

    // Recipe Keeper.app風のデータ正規化関数
    function normalizeRecipeData(recipeData) {
      console.log('🔧 レシピデータ正規化開始');
      
      const normalized = {
        title: recipeData.title || 'タイトル不明',
        description: recipeData.description || '',
        servings: recipeData.servings || '',
        ingredients: [],
        steps: [],
        notes: recipeData.notes || ''
      };
      
      // 材料の正規化
      if (recipeData.ingredients && Array.isArray(recipeData.ingredients)) {
        normalized.ingredients = recipeData.ingredients.map(ingredient => {
          return normalizeIngredientObject(ingredient);
        });
      }
      
      // 手順の正規化
      if (recipeData.steps && Array.isArray(recipeData.steps)) {
        normalized.steps = recipeData.steps.map((step, index) => {
          if (typeof step === 'string') {
            return step;
          } else if (step && typeof step === 'object') {
            return step.instruction || step.step || step.text || `手順${index + 1}`;
          }
          return `手順${index + 1}`;
        });
      }
      
      console.log('✅ データ正規化完了:', normalized);
      return normalized;
    }

    // Recipe Keeper.app風のフォールバック解析関数
    function fallbackAnalysis(content, url) {
      console.log('🔄 フォールバック解析を開始');
      
      const lines = content.split('\n').filter(line => line.trim());
      const ingredients = [];
      const steps = [];
      let title = 'レシピ';
      let description = '';
      
      // タイトルを推測
      for (const line of lines.slice(0, 10)) {
        if (line.length > 5 && line.length < 100 && !line.includes('{') && !line.includes('"')) {
          title = line.trim();
          break;
        }
      }
      
      // 日本語サイトかどうかを判定
      const isJapanese = url && (
        url.includes('.jp') || 
        url.includes('cookpad.com') || 
        url.includes('kurashiru.com')
      ) || /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(content);
      
      // 材料らしい行を検出
      for (const line of lines) {
        if (isIngredientLine(line, isJapanese)) {
          const ingredient = parseIngredientLine(line, isJapanese);
          if (ingredient) {
            ingredients.push(ingredient);
          }
        }
      }
      
      // 手順らしい行を検出
      for (const line of lines) {
        if (isStepLine(line, isJapanese)) {
          const step = cleanStepText(line);
          if (step) {
            steps.push(step);
          }
        }
      }
      
      const fallbackData = {
        title: title,
        description: description,
        servings: '',
        ingredients: ingredients,
        steps: steps,
        notes: 'フォールバック解析により生成'
      };
      
      console.log('🔄 フォールバック解析完了:', fallbackData);
      return fallbackData;
    }

    // 材料行かどうかを判定（Recipe Keeper.app準拠）
    function isIngredientLine(line, isJapanese = false) {
      const trimmed = line.trim();
      
      // 基本的な除外条件
      if (!trimmed || 
          trimmed.length < 2 || 
          trimmed.length > 150 ||
          trimmed.includes('作り方') || 
          trimmed.includes('手順') ||
          trimmed.includes('Instructions') ||
          trimmed.includes('Method') ||
          trimmed.includes('Steps')) {
        return false;
      }
      
      if (isJapanese) {
        // 日本語の材料パターン（Recipe Keeper.app準拠）
        return /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(trimmed) && 
               (
                 // 数字+日本語単位
                 /\d+[gmlカップ大さじ小さじ個枚本袋缶適量少々]/.test(trimmed) ||
                 // 全角数字+日本語単位
                 /[０-９]+[ｇｍｌカップ大さじ小さじ個枚本袋缶適量少々]/.test(trimmed) ||
                 // コロン区切り
                 /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+\s*[：:]\s*\d/.test(trimmed) ||
                 // 特殊分量
                 /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+\s*[：:]\s*(適量|少々|お好み|ひとつまみ|ひと振り)/.test(trimmed) ||
                 // 価格情報
                 /\d+円/.test(trimmed)
               );
      } else {
        // 英語の材料パターン（Recipe Keeper.app準拠）
        return (
          // 標準的な単位
          /\d+\s*(g|ml|cup|tbsp|tsp|oz|lb|kg|l|dl|cl)/.test(trimmed) ||
          // 分数
          /\d+\/\d+/.test(trimmed) ||
          // サイズ表現
          /\d+\s+(large|medium|small|whole|piece|slice)/.test(trimmed) ||
          // ダッシュ区切り
          /\w+\s*[-–—]\s*\d+/.test(trimmed) ||
          // コロン区切り
          /\w+\s*:\s*\d+/.test(trimmed) ||
          // 特殊表現
          /(to taste|as needed|pinch|dash)/.test(trimmed.toLowerCase())
        );
      }
    }

    // 材料行を解析（Recipe Keeper.app最適化版）
    function parseIngredientLine(line, isJapanese = false) {
      const trimmed = line.trim();
      console.log('🔍 材料行解析:', trimmed);
      
      if (isJapanese) {
        // 日本語材料の高精度解析（Recipe Keeper.app準拠）
        
        // パターン1: "材料名 分量単位 価格円"
        const pattern1 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Zgmlカップ大さじ小さじ個枚本袋缶適量少々\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)\s+(\d+)円$/);
        if (pattern1) {
          console.log('✅ パターン1適用: 材料名+分量単位+価格');
          return {
            item: pattern1[1].trim(),
            quantity: pattern1[2].trim(),
            unit: pattern1[3].trim(),
            price: pattern1[4].trim()
          };
        }

        // パターン2: "材料名 価格円"
        const pattern2 = trimmed.match(/^(.+?)\s+(\d+)円$/);
        if (pattern2) {
          console.log('✅ パターン2適用: 材料名+価格');
          return {
            item: pattern2[1].trim(),
            quantity: '',
            unit: '',
            price: pattern2[2].trim()
          };
        }

        // パターン3: "材料名 分量単位"
        const pattern3 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Zgmlカップ大さじ小さじ個枚本袋缶適量少々\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)$/);
        if (pattern3) {
          console.log('✅ パターン3適用: 材料名+分量単位');
          return {
            item: pattern3[1].trim(),
            quantity: pattern3[2].trim(),
            unit: pattern3[3].trim()
          };
        }

        // パターン4: "材料名 分量"
        const pattern4 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)$/);
        if (pattern4) {
          console.log('✅ パターン4適用: 材料名+分量');
          return {
            item: pattern4[1].trim(),
            quantity: pattern4[2].trim(),
            unit: ''
          };
        }

        // パターン5: "材料名：分量単位" (コロン区切り)
        const pattern5 = trimmed.match(/^(.+?)\s*[：:]\s*(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Zgmlカップ大さじ小さじ個枚本袋缶適量少々\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]*)$/);
        if (pattern5) {
          console.log('✅ パターン5適用: 材料名：分量単位');
          return {
            item: pattern5[1].trim(),
            quantity: pattern5[2].trim(),
            unit: pattern5[3].trim() || ''
          };
        }

        // パターン6: "材料名：分量" (コロン区切り、単位なし)
        const pattern6 = trimmed.match(/^(.+?)\s*[：:]\s*(\d+(?:\.\d+)?(?:\/\d+)?)$/);
        if (pattern6) {
          console.log('✅ パターン6適用: 材料名：分量');
          return {
            item: pattern6[1].trim(),
            quantity: pattern6[2].trim(),
            unit: ''
          };
        }

        // パターン7: "材料名：適量・少々" (特殊分量)
        const pattern7 = trimmed.match(/^(.+?)\s*[：:]\s*(適量|少々|お好み|ひとつまみ|ひと振り)$/);
        if (pattern7) {
          console.log('✅ パターン7適用: 材料名：特殊分量');
          return {
            item: pattern7[1].trim(),
            quantity: pattern7[2].trim(),
            unit: ''
          };
        }

        // パターン8: 全角数字対応
        const pattern8 = trimmed.match(/^(.+?)\s+([０-９]+(?:\.[０-９]+)?)\s*([a-zA-Zgmlカップ大さじ小さじ個枚本袋缶適量少々\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]*)$/);
        if (pattern8) {
          console.log('✅ パターン8適用: 全角数字');
          // 全角数字を半角に変換
          const quantity = pattern8[2].replace(/[０-９]/g, (match) => String.fromCharCode(match.charCodeAt(0) - 0xFEE0));
          return {
            item: pattern8[1].trim(),
            quantity: quantity,
            unit: pattern8[3].trim() || ''
          };
        }

      } else {
        // 英語材料の高精度解析
        
        // パターン1: "quantity unit ingredient"
        const pattern1 = trimmed.match(/^(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)\s+(.+)$/);
        if (pattern1) {
          console.log('✅ 英語パターン1: quantity unit ingredient');
          return {
            item: pattern1[3].trim(),
            quantity: pattern1[1].trim(),
            unit: pattern1[2].trim()
          };
        }

        // パターン2: "ingredient - quantity unit"
        const pattern2 = trimmed.match(/^(.+?)\s*[-–—]\s*(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)$/);
        if (pattern2) {
          console.log('✅ 英語パターン2: ingredient - quantity unit');
          return {
            item: pattern2[1].trim(),
            quantity: pattern2[2].trim(),
            unit: pattern2[3].trim()
          };
        }

        // パターン3: "ingredient: quantity unit"
        const pattern3 = trimmed.match(/^(.+?)\s*:\s*(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)$/);
        if (pattern3) {
          console.log('✅ 英語パターン3: ingredient: quantity unit');
          return {
            item: pattern3[1].trim(),
            quantity: pattern3[2].trim(),
            unit: pattern3[3].trim()
          };
        }

        // パターン4: "ingredient quantity unit"
        const pattern4 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)$/);
        if (pattern4) {
          console.log('✅ 英語パターン4: ingredient quantity unit');
          return {
            item: pattern4[1].trim(),
            quantity: pattern4[2].trim(),
            unit: pattern4[3].trim()
          };
        }
      }
      
      console.log('⚠️ フォールバック: パターンマッチ失敗');
      // フォールバック: 材料名のみ
      return {
        item: trimmed,
        quantity: '',
        unit: ''
      };
    }

    // 手順行かどうかを判定
    function isStepLine(line, isJapanese = false) {
      const trimmed = line.trim();
      
      if (isJapanese) {
        return /^\d+[．.]/.test(trimmed) ||
               /^[０-９]+[．.]/.test(trimmed) ||
               /^手順\s*\d+/.test(trimmed) ||
               /作り方|手順|方法/.test(trimmed);
      } else {
        return /^\d+\./.test(trimmed) ||
               /^step\s+\d+/i.test(trimmed) ||
               /^instruction/i.test(trimmed);
      }
    }

  </script>
</body>
</html>
